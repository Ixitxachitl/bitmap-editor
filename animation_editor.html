<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MeshPet Animation Editor</title>
  <style>
    :root{
      --bg:#0f1115;--panel:#161a23;--panel-2:#1e2430;--text:#e5e9f0;--muted:#9aa4b2;--accent:#7c90ff;--grid:#2a3140;--on:#e5e9f0;--off:#0f1115;
      --danger:#ff6b6b;--ok:#22c55e;--warn:#f59e0b;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0f1115,#121624 60%);color:var(--text);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;background:var(--panel);border-bottom:1px solid #232a3a;gap:10px;flex-wrap:wrap}
    h1{font-size:18px;margin:0;font-weight:700;letter-spacing:.2px}
    h1 span{color:var(--accent)}
    .wrap{display:grid;grid-template-columns: 320px 1fr 280px;gap:14px;padding:14px;min-height:calc(100vh - 60px)}
    .col{display:grid;gap:14px;align-content:start}
    .card{background:var(--panel);border:1px solid #222a3a;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .card h2{font-size:13px;font-weight:700;margin:0;padding:10px 14px;border-bottom:1px solid #222a3a;color:#cbd5e1;display:flex;align-items:center;gap:8px}
    .card .body{padding:12px 14px}
    label{display:block;font-size:11px;color:var(--muted);margin:8px 0 4px}
    input[type="number"],input[type="text"],select,textarea{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #243048;background:var(--panel-2);color:var(--text);font-family:inherit;font-size:12px}
    textarea{min-height:200px;resize:vertical}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{appearance:none;border:1px solid #2b3650;background:#202635;color:var(--text);padding:7px 11px;border-radius:10px;font-weight:600;font-size:11px;cursor:pointer;white-space:nowrap}
    .btn:hover{filter:brightness(1.15)}
    .btn.primary{background:linear-gradient(180deg,#6378ff,#5a6df8);border-color:#5461de;color:white}
    .btn.ghost{background:transparent;border-color:#303a57}
    .btn.warn{background:#3b2a12;border-color:#5d3d12;color:#ffd68a}
    .btn.danger{background:#3c1c1c;border-color:#5b2323;color:#ffb4b4}
    .btn.small{padding:5px 8px;font-size:10px}
    .btn.active{background:#2d3a5a;border-color:var(--accent)}
    canvas{background:var(--off);border:1px solid #252c3e;border-radius:10px;image-rendering:pixelated;cursor:crosshair}
    canvas.move-cursor{cursor:move}
    .legend{font-size:11px;color:var(--muted);margin-top:8px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    
    /* Animation list */
    .anim-list{max-height:200px;overflow-y:auto;border:1px solid #243048;border-radius:8px;background:var(--panel-2)}
    .anim-item{padding:8px 10px;border-bottom:1px solid #1a2030;cursor:pointer;font-size:12px;display:flex;justify-content:space-between;align-items:center}
    .anim-item:hover{background:#232d42}
    .anim-item.selected{background:#2a3a5a;border-left:3px solid var(--accent)}
    .anim-item .name{font-weight:600}
    .anim-item .count{color:var(--muted);font-size:10px}
    
    /* Frame strip */
    .frame-strip{display:flex;gap:6px;flex-wrap:wrap;padding:8px;background:var(--panel-2);border-radius:8px;min-height:60px;align-items:center}
    .frame-thumb{width:48px;height:48px;border:2px solid #2a3a50;border-radius:6px;cursor:pointer;image-rendering:pixelated;background:#0f1115}
    .frame-thumb.selected{border-color:var(--accent);box-shadow:0 0 8px rgba(124,144,255,0.4)}
    .frame-thumb:hover{border-color:#5a6a8a}
    .add-frame{width:48px;height:48px;border:2px dashed #3a4a60;border-radius:6px;display:flex;align-items:center;justify-content:center;cursor:pointer;color:#5a6a8a;font-size:20px}
    .add-frame:hover{border-color:var(--accent);color:var(--accent)}
    
    /* Preview */
    .preview-container{text-align:center}
    .preview-container canvas{margin:10px auto;display:block}
    .playback-controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
    
    /* Editor tools */
    .tools{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:10px}
    
    /* Selection overlay */
    .selection-overlay{position:absolute;border:2px dashed var(--accent);background:rgba(124,144,255,0.1);pointer-events:none;box-sizing:border-box}
    .selection-handles{position:absolute;pointer-events:none}
    .canvas-wrapper{position:relative;display:inline-block}
    
    /* Clipboard import modal */
    .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:1000}
    .modal-overlay.active{display:flex}
    .modal{background:var(--panel);border:1px solid #222a3a;border-radius:16px;padding:20px;max-width:500px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,.4)}
    .modal h3{margin:0 0 15px;font-size:16px;color:var(--text)}
    .modal-preview{display:flex;gap:15px;margin:15px 0}
    .modal-preview canvas{border:1px solid #2a3a50;border-radius:8px;image-rendering:pixelated}
    .modal-preview-label{font-size:11px;color:var(--muted);margin-bottom:5px}
    .modal-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:15px}
    .threshold-control{margin:10px 0}
    .threshold-control label{display:flex;align-items:center;gap:10px}
    .threshold-control input[type="range"]{flex:1}
    
    @media(max-width:1100px){.wrap{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <header>
    <h1>üêæ <span>MeshPet</span> Animation Editor</h1>
    <div class="row">
      <button class="btn" id="importFileBtn">Import PetImages.h</button>
      <button class="btn primary" id="exportBtn">Export PetImages.h</button>
      <button class="btn" id="copyBtn">Copy to Clipboard</button>
    </div>
  </header>

  <div class="wrap">
    <!-- Left: Animation & Frame Selection -->
    <div class="col">
      <section class="card">
        <h2>üé¨ Animations</h2>
        <div class="body">
          <div class="row" style="margin-bottom:10px">
            <select id="animSelect" style="flex:1"></select>
            <button class="btn small" id="addAnimBtn">+ Add</button>
            <button class="btn small danger" id="delAnimBtn">Delete</button>
          </div>
          <label>Animation Name (C identifier)</label>
          <input type="text" id="animName" placeholder="e.g. petIdle"/>
          <label>Comment</label>
          <input type="text" id="animComment" placeholder="e.g. Idle breathing animation"/>
        </div>
      </section>
      
      <section class="card">
        <h2>üñºÔ∏è Frames</h2>
        <div class="body">
          <div class="frame-strip" id="frameStrip">
            <div class="add-frame" id="addFrameBtn">+</div>
          </div>
          <div class="row" style="margin-top:10px">
            <button class="btn small" id="dupFrameBtn">Duplicate</button>
            <button class="btn small" id="delFrameBtn">Delete Frame</button>
            <button class="btn small" id="moveLeftBtn">‚óÄ</button>
            <button class="btn small" id="moveRightBtn">‚ñ∂</button>
          </div>
        </div>
      </section>
      
      <section class="card">
        <h2>‚ñ∂Ô∏è Preview</h2>
        <div class="body preview-container">
          <canvas id="preview" width="72" height="72"></canvas>
          <div class="playback-controls">
            <button class="btn small" id="playBtn">‚ñ∂ Play</button>
            <button class="btn small" id="stopBtn">‚èπ Stop</button>
            <label style="margin:0;display:flex;align-items:center;gap:4px">
              <span>Speed:</span>
              <input type="range" id="speedSlider" min="100" max="1000" value="300" style="width:80px"/>
            </label>
          </div>
        </div>
      </section>
      
      <section class="card">
        <h2>‚öôÔ∏è Settings</h2>
        <div class="body">
          <div class="row">
            <div style="flex:1">
              <label>Width</label>
              <input type="number" id="globalW" value="24" min="1" max="64"/>
            </div>
            <div style="flex:1">
              <label>Height</label>
              <input type="number" id="globalH" value="24" min="1" max="64"/>
            </div>
          </div>
          <label>Zoom</label>
          <input type="range" id="zoom" min="8" max="24" value="14"/>
        </div>
      </section>
    </div>

    <!-- Center: Editor -->
    <section class="card">
      <h2>‚úèÔ∏è Editor</h2>
      <div class="body">
        <div class="tools">
          <button class="btn small active" data-tool="draw">Draw</button>
          <button class="btn small" data-tool="erase">Erase</button>
          <button class="btn small" data-tool="line">Line</button>
          <button class="btn small" data-tool="rect">Rect</button>
          <button class="btn small" data-tool="fill">Fill</button>
          <button class="btn small" data-tool="select">Select</button>
          <span style="border-left:1px solid #3a4a60;height:20px;margin:0 4px"></span>
          <button class="btn small" id="clearBtn">Clear</button>
          <button class="btn small" id="invertBtn">Invert</button>
          <button class="btn small" id="flipHBtn">Flip H</button>
          <button class="btn small" id="flipVBtn">Flip V</button>
          <button class="btn small" id="undoBtn">Undo</button>
          <button class="btn small" id="redoBtn">Redo</button>
        </div>
        <div class="canvas-wrapper" id="canvasWrapper">
          <canvas id="grid" width="336" height="336"></canvas>
          <div class="selection-overlay" id="selectionOverlay" style="display:none"></div>
        </div>
        <div class="legend">Left-click: draw ‚Ä¢ Right-click: erase ‚Ä¢ Ctrl+Z/Y: undo/redo ‚Ä¢ Ctrl+C/X/V: copy/cut/paste</div>
      </div>
    </section>

    <!-- Right: Output -->
    <div class="col">
      <section class="card" style="flex:1">
        <h2>üìÑ Output</h2>
        <div class="body">
          <textarea id="output" class="mono" readonly placeholder="Generated code will appear here..."></textarea>
          <div class="legend">This generates the complete PetImages.h file with all animations.</div>
        </div>
      </section>
      
      <section class="card">
        <h2>üì• Import Frame</h2>
        <div class="body">
          <label>Paste hex array</label>
          <textarea id="importHex" class="mono" style="min-height:80px" placeholder="0x00, 0x1C, ..."></textarea>
          <div class="row" style="margin-top:8px">
            <button class="btn small" id="importFrameBtn">Import to Current Frame</button>
          </div>
          <div style="border-top:1px solid #2a3a50;margin:12px 0"></div>
          <label>Paste image from clipboard</label>
          <button class="btn small" id="pasteImageBtn" style="margin-top:6px">üìã Paste Image (Ctrl+V)</button>
          <div class="legend">Paste any image to convert to binary bitmap</div>
        </div>
      </section>
    </div>
  </div>

  <!-- Clipboard Import Modal -->
  <div class="modal-overlay" id="clipboardModal">
    <div class="modal">
      <h3>üìã Import Image from Clipboard</h3>
      <div class="modal-preview">
        <div>
          <div class="modal-preview-label">Original</div>
          <canvas id="clipboardOriginal" width="96" height="96"></canvas>
        </div>
        <div>
          <div class="modal-preview-label">Binary Preview (<span id="previewSize"></span>)</div>
          <canvas id="clipboardBinary" width="96" height="96"></canvas>
        </div>
      </div>
      <div class="threshold-control">
        <label>
          <span style="font-size:12px;min-width:70px">Threshold:</span>
          <input type="range" id="thresholdSlider" min="0" max="255" value="128"/>
          <span id="thresholdValue" style="font-size:12px;min-width:30px">128</span>
        </label>
      </div>
      <div class="threshold-control">
        <label>
          <input type="checkbox" id="invertImport"/>
          <span style="font-size:12px">Invert colors</span>
        </label>
      </div>
      <div class="legend" style="margin:8px 0">Image will be pasted at original size as a movable selection.</div>
      <div class="modal-actions">
        <button class="btn ghost" id="cancelClipboard">Cancel</button>
        <button class="btn primary" id="applyClipboard">Paste as Selection</button>
      </div>
    </div>
  </div>

  <input type="file" id="fileInput" accept=".h,.txt" style="display:none"/>

  <script>
    // ============================================================================
    // STATE
    // ============================================================================
    const FRAME_W = 24, FRAME_H = 24;
    
    const defaultAnimations = [
      { name: 'petIdle', comment: 'Idle/breathing animation', frames: [] },
      { name: 'petWalk', comment: '4 frame walk cycle', frames: [] },
      { name: 'petHappy', comment: 'Happy bounce', frames: [] },
      { name: 'petSleep', comment: 'Sleeping with Zzz', frames: [] },
      { name: 'petExcited', comment: 'Jumping/excited', frames: [] },
      { name: 'petEating', comment: 'Eating/receiving data', frames: [] },
      { name: 'petPlaying', comment: 'Playful animation', frames: [] },
      { name: 'petAlert', comment: 'Alert/attention', frames: [] },
      { name: 'petSad', comment: 'Sad/lonely', frames: [] },
      { name: 'petReading', comment: 'Reading text messages', frames: [] },
      { name: 'petLooking', comment: 'Looking around', frames: [] },
      { name: 'petWaving', comment: 'Waving hello', frames: [] },
      { name: 'petThinking', comment: 'Thinking/processing', frames: [] },
      { name: 'petScared', comment: 'Scared/alarmed', frames: [] },
      { name: 'petHopping', comment: 'Happy hopping', frames: [] },
      { name: 'petScratching', comment: 'Idle scratching', frames: [] },
      { name: 'petDancing', comment: 'Happy dancing', frames: [] },
      { name: 'petYawning', comment: 'Tired yawning', frames: [] },
      { name: 'petSniffing', comment: 'Curious sniffing', frames: [] },
    ];
    
    let state = {
      animations: JSON.parse(JSON.stringify(defaultAnimations)),
      currentAnim: 0,
      currentFrame: 0,
      w: FRAME_W,
      h: FRAME_H,
      zoom: 14,
      tool: 'draw',
      playing: false,
      playInterval: null,
      speed: 300,
      staticIcons: [] // Non-animation images like expIcon
    };
    
    // History
    const undoStack = [], redoStack = [];
    const MAX_HISTORY = 50;
    
    // Selection state
    let selection = {
      active: false,
      startX: 0, startY: 0,
      endX: 0, endY: 0,
      dragging: false,
      dragOffsetX: 0, dragOffsetY: 0,
      floatingPixels: null, // pixels being moved
      originalPixels: null  // backup for cancel
    };
    
    // Clipboard import state
    let clipboardImage = null;
    let clipboardThreshold = 128;
    let clipboardInvert = false;
    
    // Internal clipboard for copy/paste within editor
    let internalClipboard = null; // 2D array of pixels
    
    // Elements
    const $ = s => document.querySelector(s);
    const grid = $('#grid'), g = grid.getContext('2d');
    const preview = $('#preview'), gp = preview.getContext('2d');
    const animSelect = $('#animSelect');
    const frameStrip = $('#frameStrip');
    const output = $('#output');
    const selectionOverlay = $('#selectionOverlay');
    
    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    function init() {
      // Add empty first frame to each animation
      state.animations.forEach(a => {
        if (a.frames.length === 0) {
          a.frames.push(new Array(state.w * state.h).fill(0));
        }
      });
      
      populateAnimSelect();
      updateFrameStrip();
      resizeCanvas();
      draw();
      bindEvents();
      generateOutput();
    }
    
    function populateAnimSelect() {
      animSelect.innerHTML = state.animations.map((a, i) => 
        `<option value="${i}">${a.name} (${a.frames.length} frames)</option>`
      ).join('');
      animSelect.value = state.currentAnim;
      $('#animName').value = state.animations[state.currentAnim].name;
      $('#animComment').value = state.animations[state.currentAnim].comment;
    }
    
    function updateFrameStrip() {
      const anim = state.animations[state.currentAnim];
      const addBtn = $('#addFrameBtn');
      
      // Remove old thumbs
      frameStrip.querySelectorAll('.frame-thumb').forEach(el => el.remove());
      
      // Add frame thumbnails
      anim.frames.forEach((frame, i) => {
        const thumb = document.createElement('canvas');
        thumb.className = 'frame-thumb' + (i === state.currentFrame ? ' selected' : '');
        thumb.width = 48;
        thumb.height = 48;
        thumb.dataset.index = i;
        thumb.onclick = () => selectFrame(i);
        frameStrip.insertBefore(thumb, addBtn);
        drawThumb(thumb, frame);
      });
    }
    
    function drawThumb(canvas, pixels) {
      const ctx = canvas.getContext('2d');
      const scale = Math.floor(48 / Math.max(state.w, state.h));
      ctx.fillStyle = '#0f1115';
      ctx.fillRect(0, 0, 48, 48);
      for (let y = 0; y < state.h; y++) {
        for (let x = 0; x < state.w; x++) {
          if (pixels[y * state.w + x]) {
            ctx.fillStyle = '#e5e9f0';
            ctx.fillRect(x * scale, y * scale, scale, scale);
          }
        }
      }
    }
    
    function selectFrame(i) {
      state.currentFrame = Math.max(0, Math.min(i, currentAnim().frames.length - 1));
      updateFrameStrip();
      draw();
    }
    
    function currentAnim() {
      return state.animations[state.currentAnim];
    }
    
    function currentPixels() {
      const anim = currentAnim();
      if (!anim.frames[state.currentFrame]) {
        anim.frames[state.currentFrame] = new Array(state.w * state.h).fill(0);
      }
      return anim.frames[state.currentFrame];
    }
    
    // ============================================================================
    // DRAWING
    // ============================================================================
    function resizeCanvas() {
      grid.width = state.w * state.zoom;
      grid.height = state.h * state.zoom;
    }
    
    function draw() {
      const z = state.zoom;
      const pixels = currentPixels();
      
      g.fillStyle = '#0b0e16';
      g.fillRect(0, 0, grid.width, grid.height);
      
      for (let y = 0; y < state.h; y++) {
        for (let x = 0; x < state.w; x++) {
          g.fillStyle = pixels[y * state.w + x] ? '#e5e9f0' : '#0f1115';
          g.fillRect(x * z, y * z, z, z);
        }
      }
      
      // Draw floating selection pixels (being moved)
      if (selection.floatingPixels && selection.active) {
        const selMinX = Math.min(selection.startX, selection.endX);
        const selMinY = Math.min(selection.startY, selection.endY);
        
        for (let dy = 0; dy < selection.floatingPixels.length; dy++) {
          for (let dx = 0; dx < selection.floatingPixels[dy].length; dx++) {
            const px = selMinX + dx;
            const py = selMinY + dy;
            // Draw even if outside canvas bounds (will be clipped on commit)
            if (px >= 0 && px < state.w && py >= 0 && py < state.h) {
              if (selection.floatingPixels[dy][dx]) {
                g.fillStyle = '#7cffb0';
                g.fillRect(px * z, py * z, z, z);
              }
            }
          }
        }
      }
      
      // Grid lines
      g.strokeStyle = '#2b3245';
      g.lineWidth = 1;
      g.beginPath();
      for (let x = 0; x <= state.w; x++) {
        g.moveTo(x * z + 0.5, 0);
        g.lineTo(x * z + 0.5, grid.height);
      }
      for (let y = 0; y <= state.h; y++) {
        g.moveTo(0, y * z + 0.5);
        g.lineTo(grid.width, y * z + 0.5);
      }
      g.stroke();
      
      // Draw selection rectangle
      drawSelectionOverlay();
      
      // Update preview
      drawPreview();
      updateFrameStrip();
    }
    
    function drawSelectionOverlay() {
      if (!selection.active || state.tool !== 'select') {
        selectionOverlay.style.display = 'none';
        return;
      }
      
      const z = state.zoom;
      let minX, minY, width, height;
      
      if (selection.floatingPixels) {
        // For floating selections (pasted or lifted), use direct coords
        minX = selection.startX;
        minY = selection.startY;
        width = selection.floatingPixels[0].length;
        height = selection.floatingPixels.length;
      } else {
        // For marquee selection being drawn
        minX = Math.min(selection.startX, selection.endX);
        minY = Math.min(selection.startY, selection.endY);
        width = Math.abs(selection.endX - selection.startX) + 1;
        height = Math.abs(selection.endY - selection.startY) + 1;
      }
      
      selectionOverlay.style.display = 'block';
      selectionOverlay.style.left = (minX * z) + 'px';
      selectionOverlay.style.top = (minY * z) + 'px';
      selectionOverlay.style.width = (width * z) + 'px';
      selectionOverlay.style.height = (height * z) + 'px';
    }
    
    function drawPreview() {
      const pixels = currentPixels();
      const scale = 3;
      preview.width = state.w * scale;
      preview.height = state.h * scale;
      gp.fillStyle = '#0f1115';
      gp.fillRect(0, 0, preview.width, preview.height);
      for (let y = 0; y < state.h; y++) {
        for (let x = 0; x < state.w; x++) {
          if (pixels[y * state.w + x]) {
            gp.fillStyle = '#e5e9f0';
            gp.fillRect(x * scale, y * scale, scale, scale);
          }
        }
      }
    }
    
    function drawAnimatedPreview(frameIndex) {
      const anim = currentAnim();
      if (frameIndex >= anim.frames.length) frameIndex = 0;
      const pixels = anim.frames[frameIndex];
      const scale = 3;
      gp.fillStyle = '#0f1115';
      gp.fillRect(0, 0, preview.width, preview.height);
      for (let y = 0; y < state.h; y++) {
        for (let x = 0; x < state.w; x++) {
          if (pixels && pixels[y * state.w + x]) {
            gp.fillStyle = '#e5e9f0';
            gp.fillRect(x * scale, y * scale, scale, scale);
          }
        }
      }
    }
    
    // ============================================================================
    // PIXEL OPERATIONS
    // ============================================================================
    function setPx(x, y, v) {
      if (x < 0 || y < 0 || x >= state.w || y >= state.h) return;
      currentPixels()[y * state.w + x] = v;
    }
    
    function getPx(x, y) {
      if (x < 0 || y < 0 || x >= state.w || y >= state.h) return 0;
      return currentPixels()[y * state.w + x] | 0;
    }
    
    function clearFrame() {
      pushHistory();
      const pixels = currentPixels();
      for (let i = 0; i < pixels.length; i++) pixels[i] = 0;
      draw();
      generateOutput();
    }
    
    function invertFrame() {
      pushHistory();
      
      // If there's an active selection, only invert that
      if (selection.active) {
        if (selection.floatingPixels) {
          // Invert floating selection
          for (let dy = 0; dy < selection.floatingPixels.length; dy++) {
            for (let dx = 0; dx < selection.floatingPixels[dy].length; dx++) {
              selection.floatingPixels[dy][dx] = selection.floatingPixels[dy][dx] ? 0 : 1;
            }
          }
        } else {
          // Invert marquee selection area
          const minX = Math.min(selection.startX, selection.endX);
          const minY = Math.min(selection.startY, selection.endY);
          const maxX = Math.max(selection.startX, selection.endX);
          const maxY = Math.max(selection.startY, selection.endY);
          const pixels = currentPixels();
          for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
              if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                const i = y * state.w + x;
                pixels[i] = pixels[i] ? 0 : 1;
              }
            }
          }
        }
      } else {
        // Invert entire frame
        const pixels = currentPixels();
        for (let i = 0; i < pixels.length; i++) pixels[i] = pixels[i] ? 0 : 1;
      }
      
      draw();
      generateOutput();
    }
    
    function flipH() {
      pushHistory();
      
      // If there's an active selection, only flip that
      if (selection.active) {
        if (selection.floatingPixels) {
          // Flip floating selection horizontally
          selection.floatingPixels = selection.floatingPixels.map(row => [...row].reverse());
        } else {
          // Flip marquee selection area
          const minX = Math.min(selection.startX, selection.endX);
          const minY = Math.min(selection.startY, selection.endY);
          const maxX = Math.max(selection.startX, selection.endX);
          const maxY = Math.max(selection.startY, selection.endY);
          const pixels = currentPixels();
          
          for (let y = minY; y <= maxY; y++) {
            // Extract row within selection
            const row = [];
            for (let x = minX; x <= maxX; x++) {
              if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                row.push(pixels[y * state.w + x]);
              } else {
                row.push(0);
              }
            }
            // Write back reversed
            row.reverse();
            for (let x = minX; x <= maxX; x++) {
              if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                pixels[y * state.w + x] = row[x - minX];
              }
            }
          }
        }
      } else {
        // Flip entire frame
        const pixels = currentPixels();
        const out = new Array(state.w * state.h).fill(0);
        for (let y = 0; y < state.h; y++) {
          for (let x = 0; x < state.w; x++) {
            out[y * state.w + x] = pixels[y * state.w + (state.w - 1 - x)];
          }
        }
        currentAnim().frames[state.currentFrame] = out;
      }
      
      draw();
      generateOutput();
    }
    
    function flipV() {
      pushHistory();
      
      // If there's an active selection, only flip that
      if (selection.active) {
        if (selection.floatingPixels) {
          // Flip floating selection vertically
          selection.floatingPixels = [...selection.floatingPixels].reverse();
        } else {
          // Flip marquee selection area
          const minX = Math.min(selection.startX, selection.endX);
          const minY = Math.min(selection.startY, selection.endY);
          const maxX = Math.max(selection.startX, selection.endX);
          const maxY = Math.max(selection.startY, selection.endY);
          const height = maxY - minY + 1;
          const pixels = currentPixels();
          
          // Extract selection into temp array
          const temp = [];
          for (let y = minY; y <= maxY; y++) {
            temp[y - minY] = [];
            for (let x = minX; x <= maxX; x++) {
              if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                temp[y - minY][x - minX] = pixels[y * state.w + x];
              } else {
                temp[y - minY][x - minX] = 0;
              }
            }
          }
          
          // Write back flipped
          for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
              if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                pixels[y * state.w + x] = temp[maxY - y][x - minX];
              }
            }
          }
        }
      } else {
        // Flip entire frame
        const pixels = currentPixels();
        const out = new Array(state.w * state.h).fill(0);
        for (let y = 0; y < state.h; y++) {
          for (let x = 0; x < state.w; x++) {
            out[y * state.w + x] = pixels[(state.h - 1 - y) * state.w + x];
          }
        }
        currentAnim().frames[state.currentFrame] = out;
      }
      
      draw();
      generateOutput();
    }
    
    function floodFill(startX, startY, newVal) {
      const target = getPx(startX, startY);
      if (target === newVal) return;
      const stack = [[startX, startY]];
      while (stack.length) {
        const [x, y] = stack.pop();
        if (x < 0 || y < 0 || x >= state.w || y >= state.h) continue;
        if (getPx(x, y) !== target) continue;
        setPx(x, y, newVal);
        stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
      }
    }
    
    // ============================================================================
    // HISTORY
    // ============================================================================
    function snapshot() {
      return JSON.parse(JSON.stringify({
        animations: state.animations,
        currentAnim: state.currentAnim,
        currentFrame: state.currentFrame
      }));
    }
    
    function pushHistory() {
      undoStack.push(snapshot());
      if (undoStack.length > MAX_HISTORY) undoStack.shift();
      redoStack.length = 0;
    }
    
    function undo() {
      if (!undoStack.length) return;
      redoStack.push(snapshot());
      const prev = undoStack.pop();
      state.animations = prev.animations;
      state.currentAnim = prev.currentAnim;
      state.currentFrame = prev.currentFrame;
      populateAnimSelect();
      updateFrameStrip();
      draw();
      generateOutput();
    }
    
    function redo() {
      if (!redoStack.length) return;
      undoStack.push(snapshot());
      const next = redoStack.pop();
      state.animations = next.animations;
      state.currentAnim = next.currentAnim;
      state.currentFrame = next.currentFrame;
      populateAnimSelect();
      updateFrameStrip();
      draw();
      generateOutput();
    }
    
    // ============================================================================
    // MOUSE HANDLING
    // ============================================================================
    let drawing = false, lastX = -1, lastY = -1, lineStart = null, shapeBase = null;
    let selectStart = null; // for selection tool
    
    grid.addEventListener('contextmenu', e => e.preventDefault());
    
    grid.addEventListener('mousedown', e => {
      const { x, y } = eventToCell(e);
      const isErase = e.button === 2;
      
      // Selection tool
      if (state.tool === 'select') {
        // Check if clicking inside existing selection to drag
        if (selection.active && isInsideSelection(x, y)) {
          // Start dragging the selection
          selection.dragging = true;
          selection.dragOffsetX = x - Math.min(selection.startX, selection.endX);
          selection.dragOffsetY = y - Math.min(selection.startY, selection.endY);
          
          // If we don't have floating pixels yet, lift them from the canvas
          if (!selection.floatingPixels) {
            pushHistory();
            liftSelection();
          }
          return;
        } else {
          // Start new selection (commit any existing one first)
          if (selection.floatingPixels) {
            commitSelection();
          }
          selectStart = { x, y };
          selection.startX = x;
          selection.startY = y;
          selection.endX = x;
          selection.endY = y;
          selection.active = true;
          selection.floatingPixels = null;
          drawing = true;
          draw();
          return;
        }
      }
      
      if (state.tool === 'line' || state.tool === 'rect') {
        lineStart = { x, y };
        shapeBase = currentPixels().slice();
        pushHistory();
        drawing = true;
        return;
      }
      
      pushHistory();
      drawing = true;
      
      // Erase tool or right-click erases
      const eraseMode = state.tool === 'erase' || isErase;
      
      if (state.tool === 'fill') {
        floodFill(x, y, eraseMode ? 0 : 1);
      } else {
        setPx(x, y, eraseMode ? 0 : 1);
      }
      lastX = x; lastY = y;
      draw();
    });
    
    grid.addEventListener('mousemove', e => {
      const { x, y } = eventToCell(e);
      const isErase = e.buttons === 2;
      
      // Selection tool - dragging selection
      if (state.tool === 'select' && selection.dragging) {
        const newMinX = x - selection.dragOffsetX;
        const newMinY = y - selection.dragOffsetY;
        
        if (selection.floatingPixels) {
          // For floating selections, just update start position
          selection.startX = newMinX;
          selection.startY = newMinY;
          // endX/endY are recalculated from floatingPixels dimensions
          selection.endX = newMinX + selection.floatingPixels[0].length - 1;
          selection.endY = newMinY + selection.floatingPixels.length - 1;
        } else {
          const width = Math.abs(selection.endX - selection.startX);
          const height = Math.abs(selection.endY - selection.startY);
          selection.startX = newMinX;
          selection.startY = newMinY;
          selection.endX = newMinX + width;
          selection.endY = newMinY + height;
        }
        draw();
        return;
      }
      
      // Selection tool - drawing selection box
      if (state.tool === 'select' && drawing && selectStart) {
        selection.endX = x;
        selection.endY = y;
        draw();
        return;
      }
      
      if (!drawing) return;
      
      if (lineStart && (state.tool === 'line' || state.tool === 'rect')) {
        currentAnim().frames[state.currentFrame] = shapeBase.slice();
        const val = isErase ? 0 : 1;
        if (state.tool === 'rect') {
          drawRect(lineStart.x, lineStart.y, x, y, val);
        } else {
          drawLine(lineStart.x, lineStart.y, x, y, val);
        }
        draw();
        return;
      }
      
      // Erase tool or right-click erases
      const eraseMode = state.tool === 'erase' || isErase;
      
      if (x !== lastX || y !== lastY) {
        if (lastX >= 0) drawLine(lastX, lastY, x, y, eraseMode ? 0 : 1);
        else setPx(x, y, eraseMode ? 0 : 1);
        lastX = x; lastY = y;
        draw();
      }
    });
    
    window.addEventListener('mouseup', () => {
      if (state.tool === 'select') {
        selection.dragging = false;
        selectStart = null;
        drawing = false;
        if (selection.floatingPixels) {
          generateOutput();
        }
        return;
      }
      
      if (drawing) generateOutput();
      drawing = false;
      lastX = -1; lastY = -1;
      lineStart = null; shapeBase = null;
    });
    
    function isInsideSelection(x, y) {
      if (!selection.active) return false;
      
      let minX, minY, maxX, maxY;
      if (selection.floatingPixels) {
        minX = selection.startX;
        minY = selection.startY;
        maxX = selection.startX + selection.floatingPixels[0].length - 1;
        maxY = selection.startY + selection.floatingPixels.length - 1;
      } else {
        minX = Math.min(selection.startX, selection.endX);
        minY = Math.min(selection.startY, selection.endY);
        maxX = Math.max(selection.startX, selection.endX);
        maxY = Math.max(selection.startY, selection.endY);
      }
      return x >= minX && x <= maxX && y >= minY && y <= maxY;
    }
    
    function liftSelection() {
      const minX = Math.min(selection.startX, selection.endX);
      const minY = Math.min(selection.startY, selection.endY);
      const maxX = Math.max(selection.startX, selection.endX);
      const maxY = Math.max(selection.startY, selection.endY);
      const width = maxX - minX + 1;
      const height = maxY - minY + 1;
      
      // Extract pixels from selection area
      selection.floatingPixels = [];
      const pixels = currentPixels();
      
      for (let dy = 0; dy < height; dy++) {
        selection.floatingPixels[dy] = [];
        for (let dx = 0; dx < width; dx++) {
          const px = minX + dx;
          const py = minY + dy;
          if (px >= 0 && px < state.w && py >= 0 && py < state.h) {
            selection.floatingPixels[dy][dx] = pixels[py * state.w + px];
            // Clear original position
            pixels[py * state.w + px] = 0;
          } else {
            selection.floatingPixels[dy][dx] = 0;
          }
        }
      }
      
      // Update selection coords to be normalized (minX, minY as start)
      selection.startX = minX;
      selection.startY = minY;
      selection.endX = maxX;
      selection.endY = maxY;
    }
    
    function commitSelection() {
      if (!selection.floatingPixels) {
        clearSelection();
        return;
      }
      
      // For floating selections, startX/startY is always the top-left
      const minX = selection.startX;
      const minY = selection.startY;
      const pixels = currentPixels();
      
      // Stamp floating pixels onto canvas (clipping to bounds)
      for (let dy = 0; dy < selection.floatingPixels.length; dy++) {
        for (let dx = 0; dx < selection.floatingPixels[dy].length; dx++) {
          const px = minX + dx;
          const py = minY + dy;
          if (px >= 0 && px < state.w && py >= 0 && py < state.h) {
            if (selection.floatingPixels[dy][dx]) {
              pixels[py * state.w + px] = 1;
            }
          }
        }
      }
      
      clearSelection();
      draw();
      generateOutput();
    }
    
    function clearSelection() {
      selection.active = false;
      selection.floatingPixels = null;
      selection.dragging = false;
      selectionOverlay.style.display = 'none';
    }
    
    function copySelection() {
      if (!selection.active) {
        toast('No selection to copy');
        return;
      }
      
      if (selection.floatingPixels) {
        // Copy floating pixels
        internalClipboard = selection.floatingPixels.map(row => [...row]);
      } else {
        // Copy from canvas (marquee selection)
        const minX = Math.min(selection.startX, selection.endX);
        const minY = Math.min(selection.startY, selection.endY);
        const maxX = Math.max(selection.startX, selection.endX);
        const maxY = Math.max(selection.startY, selection.endY);
        const width = maxX - minX + 1;
        const height = maxY - minY + 1;
        
        const pixels = currentPixels();
        internalClipboard = [];
        for (let dy = 0; dy < height; dy++) {
          internalClipboard[dy] = [];
          for (let dx = 0; dx < width; dx++) {
            const px = minX + dx;
            const py = minY + dy;
            if (px >= 0 && px < state.w && py >= 0 && py < state.h) {
              internalClipboard[dy][dx] = pixels[py * state.w + px] ? 1 : 0;
            } else {
              internalClipboard[dy][dx] = 0;
            }
          }
        }
      }
      
      // Also copy to system clipboard as image
      copySelectionToSystemClipboard(internalClipboard);
      toast(`Copied ${internalClipboard[0].length}√ó${internalClipboard.length} pixels`);
    }
    
    async function copySelectionToSystemClipboard(pixels2D) {
      // Copy as text representation to system clipboard
      // This clears any image from clipboard so paste won't get confused
      const width = pixels2D[0].length;
      const height = pixels2D.length;
      
      // Create a simple text representation
      let text = `[MeshPet ${width}x${height}]\n`;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          text += pixels2D[y][x] ? '‚ñà' : '¬∑';
        }
        text += '\n';
      }
      
      try {
        await navigator.clipboard.writeText(text);
      } catch (err) {
        console.log('Could not copy to system clipboard:', err);
      }
    }
    
    function cutSelection() {
      if (!selection.active) {
        toast('No selection to cut');
        return;
      }
      
      pushHistory();
      
      // If not already floating, lift it first
      if (!selection.floatingPixels) {
        liftSelection();
      }
      
      // Copy to clipboard
      internalClipboard = selection.floatingPixels.map(row => [...row]);
      
      // Clear the floating selection (delete the pixels)
      selection.floatingPixels = null;
      clearSelection();
      draw();
      generateOutput();
      toast('Cut to clipboard');
    }
    
    function pasteFromInternalClipboard() {
      if (!internalClipboard) {
        toast('Nothing to paste');
        return;
      }
      
      // Commit any existing selection first
      if (selection.floatingPixels) {
        commitSelection();
      }
      
      pushHistory();
      
      // Create new floating selection from clipboard
      selection.floatingPixels = internalClipboard.map(row => [...row]);
      selection.startX = 0;
      selection.startY = 0;
      selection.endX = selection.floatingPixels[0].length - 1;
      selection.endY = selection.floatingPixels.length - 1;
      selection.active = true;
      selection.dragging = false;
      
      // Switch to select tool
      state.tool = 'select';
      document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
      document.querySelector('[data-tool="select"]').classList.add('active');
      
      draw();
      toast('Pasted - drag to position, Escape to commit');
    }
    
    function eventToCell(e) {
      const r = grid.getBoundingClientRect();
      const x = Math.min(state.w - 1, Math.max(0, Math.floor((e.clientX - r.left) / state.zoom)));
      const y = Math.min(state.h - 1, Math.max(0, Math.floor((e.clientY - r.top) / state.zoom)));
      return { x, y };
    }
    
    // Update cursor based on selection state
    grid.addEventListener('mousemove', e => {
      if (state.tool === 'select' && selection.active && !drawing) {
        const { x, y } = eventToCell(e);
        if (isInsideSelection(x, y)) {
          grid.classList.add('move-cursor');
        } else {
          grid.classList.remove('move-cursor');
        }
      } else if (state.tool !== 'select') {
        grid.classList.remove('move-cursor');
      }
    });
    
    function drawLine(x0, y0, x1, y1, val) {
      const dx = Math.abs(x1 - x0), dy = -Math.abs(y1 - y0);
      const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
      let err = dx + dy;
      while (true) {
        setPx(x0, y0, val);
        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 >= dy) { err += dy; x0 += sx; }
        if (e2 <= dx) { err += dx; y0 += sy; }
      }
    }
    
    function drawRect(x0, y0, x1, y1, val) {
      const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);
      const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          if (y === minY || y === maxY || x === minX || x === maxX) {
            setPx(x, y, val);
          }
        }
      }
    }
    
    // ============================================================================
    // IMPORT/EXPORT
    // ============================================================================
    function packFrame(pixels) {
      const bytes = [];
      let cur = 0, count = 0;
      for (let y = 0; y < state.h; y++) {
        for (let x = 0; x < state.w; x++) {
          const bit = pixels[y * state.w + x] ? 1 : 0;
          cur |= (bit << count);
          count++;
          if (count === 8) {
            bytes.push(cur);
            cur = 0; count = 0;
          }
        }
        // Pad row to byte boundary
        if (count !== 0) {
          bytes.push(cur);
          cur = 0; count = 0;
        }
      }
      return bytes;
    }
    
    function unpackFrame(bytes) {
      const pixels = new Array(state.w * state.h).fill(0);
      let idx = 0;
      for (let y = 0; y < state.h; y++) {
        for (let x = 0; x < state.w; x++) {
          const bitIndex = x % 8;
          if (bitIndex === 0) var b = bytes[idx++] || 0;
          pixels[y * state.w + x] = (b & (1 << bitIndex)) ? 1 : 0;
        }
        // Skip padding
        const rem = state.w % 8;
        if (rem !== 0 && (state.w % 8) !== 0) {
          // Already consumed partial byte, idx incremented
        }
      }
      return pixels;
    }
    
    function generateOutput() {
      // Filter to only animations with actual content (not just 1 empty frame)
      const activeAnims = state.animations.filter(anim => {
        if (anim.frames.length > 1) return true;
        if (anim.frames.length === 1) {
          // Check if frame has any pixels
          return anim.frames[0].some(p => p);
        }
        return false;
      });
      
      let out = `#pragma once

#include "configuration.h"

#if !MESHTASTIC_EXCLUDE_PET

/**
 * PetImages.h - Animation frames for the PetModule
 * Generated by MeshPet Animation Editor
 */

// Frame dimensions
#define PET_FRAME_WIDTH ${state.w}
#define PET_FRAME_HEIGHT ${state.h}

// Frame counts per animation
`;
      
      // Frame count defines (only for active animations)
      activeAnims.forEach(a => {
        const defName = a.name.replace(/^pet/, 'PET_').replace(/([A-Z])/g, '_$1').toUpperCase().replace(/__/g, '_') + '_FRAMES';
        out += `#define ${defName} ${a.frames.length}\n`;
      });
      
      out += '\n';
      
      // Static icons first (preserved from import)
      if (state.staticIcons && state.staticIcons.length > 0) {
        out += `// ============================================================================\n`;
        out += `// STATIC ICONS\n`;
        out += `// ============================================================================\n\n`;
        
        state.staticIcons.forEach(icon => {
          const hex = icon.bytes.map(b => '0x' + b.toString(16).toUpperCase().padStart(2, '0')).join(', ');
          if (icon.comment) {
            out += `// ${icon.name} - ${icon.comment}\n`;
          }
          out += `const uint8_t ${icon.name}[] PROGMEM = {${hex}};\n\n`;
        });
      }
      
      // Frame data (only for active animations)
      activeAnims.forEach(anim => {
        out += `// ============================================================================\n`;
        out += `// ${anim.name.toUpperCase()} - ${anim.comment}\n`;
        out += `// ============================================================================\n\n`;
        
        anim.frames.forEach((frame, i) => {
          const bytes = packFrame(frame);
          const hex = bytes.map(b => '0x' + b.toString(16).toUpperCase().padStart(2, '0')).join(', ');
          const frameName = `${anim.name}${i + 1}`;
          
          out += `// ${anim.name} Frame ${i + 1}\n`;
          out += `const uint8_t ${frameName}[] PROGMEM = {${hex}};\n\n`;
        });
      });
      
      // Frame arrays (only for active animations)
      out += `// ============================================================================\n`;
      out += `// FRAME ARRAYS\n`;
      out += `// ============================================================================\n\n`;
      
      activeAnims.forEach(anim => {
        const frameNames = anim.frames.map((_, i) => `${anim.name}${i + 1}`).join(', ');
        out += `const uint8_t *const ${anim.name}Frames[] PROGMEM = {${frameNames}};\n`;
      });
      
      // Animation count
      out += `\n// Total animations: ${activeAnims.length}`;
      if (state.staticIcons && state.staticIcons.length > 0) {
        out += `, Static icons: ${state.staticIcons.length}`;
      }
      out += `\n#define PET_ANIMATION_COUNT ${activeAnims.length}\n`;
      
      out += '\n#endif // !MESHTASTIC_EXCLUDE_PET\n';
      
      output.value = out;
    }
    
    function parseHexArray(str) {
      const bytes = [];
      str.replace(/0x[0-9a-fA-F]{1,2}/gi, m => {
        bytes.push(parseInt(m, 16));
      });
      return bytes;
    }
    
    function importFrame() {
      const hex = $('#importHex').value;
      const bytes = parseHexArray(hex);
      if (bytes.length === 0) {
        toast('No valid hex bytes found');
        return;
      }
      pushHistory();
      currentAnim().frames[state.currentFrame] = unpackFrame(bytes);
      draw();
      generateOutput();
      toast('Frame imported');
    }
    
    function importPetImagesH(content) {
      pushHistory();
      
      // Parse frame data
      const frameRegex = /const uint8_t (\w+)\[\]\s*PROGMEM\s*=\s*\{([^}]+)\}/g;
      const frames = {};
      let match;
      while ((match = frameRegex.exec(content)) !== null) {
        const name = match[1];
        const bytes = parseHexArray(match[2]);
        frames[name] = bytes;
      }
      
      // Parse dimensions
      const wMatch = content.match(/#define PET_FRAME_WIDTH (\d+)/);
      const hMatch = content.match(/#define PET_FRAME_HEIGHT (\d+)/);
      if (wMatch) state.w = parseInt(wMatch[1]);
      if (hMatch) state.h = parseInt(hMatch[1]);
      $('#globalW').value = state.w;
      $('#globalH').value = state.h;
      
      // Parse frame arrays to discover animations and their frame order
      // e.g. const uint8_t *const petIdleFrames[] PROGMEM = {petIdle1, petIdle2};
      const frameArrayRegex = /const uint8_t \*const (\w+)Frames\[\]\s*PROGMEM\s*=\s*\{([^}]+)\}/g;
      const discoveredAnims = {};
      const animationFrameNames = new Set(); // Track which frames belong to animations
      while ((match = frameArrayRegex.exec(content)) !== null) {
        const animName = match[1];
        const frameNames = match[2].split(',').map(s => s.trim()).filter(s => s);
        discoveredAnims[animName] = frameNames;
        frameNames.forEach(fn => animationFrameNames.add(fn));
      }
      
      // Parse comments for animations if available
      const commentRegex = /\/\/\s*(\w+)\s*-\s*(.+)/g;
      const comments = {};
      while ((match = commentRegex.exec(content)) !== null) {
        const name = match[1].toLowerCase();
        comments[name] = match[2].trim();
      }
      
      // Find standalone icons (frames not part of any animation)
      state.staticIcons = [];
      Object.keys(frames).forEach(frameName => {
        if (!animationFrameNames.has(frameName)) {
          // Check if it looks like an animation frame (ends with number)
          const isNumberedFrame = /\d+$/.test(frameName);
          // Check if there's a corresponding Frames array
          const baseName = frameName.replace(/\d+$/, '');
          const hasFramesArray = discoveredAnims[baseName];
          
          if (!isNumberedFrame || !hasFramesArray) {
            // This is a standalone icon
            state.staticIcons.push({
              name: frameName,
              bytes: frames[frameName],
              comment: comments[frameName.toLowerCase()] || ''
            });
          }
        }
      });
      
      // Group frames by animation - check predefined animations first
      state.animations.forEach(anim => {
        anim.frames = [];
        
        // Check if this animation was in the frame arrays
        if (discoveredAnims[anim.name]) {
          // Use the exact frame order from the file
          discoveredAnims[anim.name].forEach(frameName => {
            if (frames[frameName]) {
              anim.frames.push(unpackFrame(frames[frameName]));
            }
          });
        } else {
          // Fall back to numbered frames (up to 20)
          for (let i = 1; i <= 20; i++) {
            const frameName = `${anim.name}${i}`;
            if (frames[frameName]) {
              anim.frames.push(unpackFrame(frames[frameName]));
            }
          }
        }
        
        // Update comment if found
        const animNameLower = anim.name.toLowerCase();
        if (comments[animNameLower]) {
          anim.comment = comments[animNameLower];
        }
        
        if (anim.frames.length === 0) {
          anim.frames.push(new Array(state.w * state.h).fill(0));
        }
      });
      
      // Check for any animations in the file that aren't in our predefined list
      const predefinedNames = state.animations.map(a => a.name);
      Object.keys(discoveredAnims).forEach(animName => {
        if (!predefinedNames.includes(animName)) {
          // Add this animation
          const newAnim = {
            name: animName,
            comment: comments[animName.toLowerCase()] || 'Imported animation',
            frames: []
          };
          discoveredAnims[animName].forEach(frameName => {
            if (frames[frameName]) {
              newAnim.frames.push(unpackFrame(frames[frameName]));
            }
          });
          if (newAnim.frames.length > 0) {
            state.animations.push(newAnim);
          }
        }
      });
      
      state.currentAnim = 0;
      state.currentFrame = 0;
      resizeCanvas();
      populateAnimSelect();
      updateFrameStrip();
      draw();
      generateOutput();
      const iconCount = state.staticIcons.length;
      toast(`Imported ${Object.keys(frames).length} frames` + (iconCount ? ` + ${iconCount} icons` : ''));
    }
    
    // ============================================================================
    // CLIPBOARD IMAGE IMPORT
    // ============================================================================
    async function handlePaste(e) {
      const items = e.clipboardData?.items || [];
      for (const item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const blob = item.getAsFile();
          await processClipboardImage(blob);
          return;
        }
      }
    }
    
    async function processClipboardImage(blob) {
      const img = new Image();
      img.onload = () => {
        clipboardImage = img;
        showClipboardModal();
      };
      img.src = URL.createObjectURL(blob);
    }
    
    function showClipboardModal() {
      const modal = $('#clipboardModal');
      modal.classList.add('active');
      updateClipboardPreview();
    }
    
    function hideClipboardModal() {
      const modal = $('#clipboardModal');
      modal.classList.remove('active');
      clipboardImage = null;
    }
    
    function updateClipboardPreview() {
      if (!clipboardImage) return;
      
      const origCanvas = $('#clipboardOriginal');
      const binCanvas = $('#clipboardBinary');
      const origCtx = origCanvas.getContext('2d');
      const binCtx = binCanvas.getContext('2d');
      
      // Draw original scaled to preview size
      const scale = Math.min(96 / clipboardImage.width, 96 / clipboardImage.height);
      const scaledW = clipboardImage.width * scale;
      const scaledH = clipboardImage.height * scale;
      
      origCanvas.width = 96;
      origCanvas.height = 96;
      origCtx.fillStyle = '#1a1a2e';
      origCtx.fillRect(0, 0, 96, 96);
      origCtx.drawImage(clipboardImage, (96 - scaledW) / 2, (96 - scaledH) / 2, scaledW, scaledH);
      
      // Convert to binary at ORIGINAL size (1:1 pixel mapping)
      const imgW = clipboardImage.width;
      const imgH = clipboardImage.height;
      const binaryPixels = convertImageToBinaryOriginalSize(clipboardImage, clipboardThreshold, clipboardInvert);
      
      // Show size info
      $('#previewSize').textContent = `${imgW}√ó${imgH}px`;
      
      // Create binary preview
      binCanvas.width = 96;
      binCanvas.height = 96;
      binCtx.fillStyle = '#0f1115';
      binCtx.fillRect(0, 0, 96, 96);
      
      // Draw binary preview scaled to fit
      const pxSize = Math.min(96 / imgW, 96 / imgH);
      const offsetX = (96 - imgW * pxSize) / 2;
      const offsetY = (96 - imgH * pxSize) / 2;
      
      for (let y = 0; y < imgH; y++) {
        for (let x = 0; x < imgW; x++) {
          if (binaryPixels[y][x]) {
            binCtx.fillStyle = '#e5e9f0';
            binCtx.fillRect(offsetX + x * pxSize, offsetY + y * pxSize, pxSize, pxSize);
          }
        }
      }
    }
    
    function convertImageToBinaryOriginalSize(img, threshold, invert) {
      // Create temp canvas at original image size
      const tempCanvas = document.createElement('canvas');
      const imgW = img.width;
      const imgH = img.height;
      tempCanvas.width = imgW;
      tempCanvas.height = imgH;
      const ctx = tempCanvas.getContext('2d');
      
      // Draw image at original size
      ctx.drawImage(img, 0, 0);
      
      // Get pixel data
      const imageData = ctx.getImageData(0, 0, imgW, imgH);
      const data = imageData.data;
      
      // Create 2D array for easier use as floating selection
      const pixels = [];
      for (let y = 0; y < imgH; y++) {
        pixels[y] = [];
        for (let x = 0; x < imgW; x++) {
          const i = (y * imgW + x) * 4;
          // Convert to grayscale using luminance formula
          const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
          let isOn = gray < threshold;
          if (invert) isOn = !isOn;
          pixels[y][x] = isOn ? 1 : 0;
        }
      }
      
      return pixels;
    }
    
    function applyClipboardToFrame() {
      if (!clipboardImage) return;
      
      pushHistory();
      
      // Convert to binary at original size
      const binaryPixels = convertImageToBinaryOriginalSize(clipboardImage, clipboardThreshold, clipboardInvert);
      
      // Create floating selection with the pasted pixels
      selection.floatingPixels = binaryPixels;
      selection.startX = 0;
      selection.startY = 0;
      selection.endX = binaryPixels[0].length - 1;
      selection.endY = binaryPixels.length - 1;
      selection.active = true;
      selection.dragging = false;
      
      // Switch to select tool
      state.tool = 'select';
      document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
      document.querySelector('[data-tool="select"]').classList.add('active');
      
      hideClipboardModal();
      draw();
      toast('Image pasted - drag to position, press Escape to commit');
    }
    
    // ============================================================================
    // ANIMATION PLAYBACK
    // ============================================================================
    function playAnimation() {
      if (state.playing) return;
      state.playing = true;
      let frame = 0;
      state.playInterval = setInterval(() => {
        const anim = currentAnim();
        frame = (frame + 1) % anim.frames.length;
        drawAnimatedPreview(frame);
      }, state.speed);
    }
    
    function stopAnimation() {
      state.playing = false;
      if (state.playInterval) {
        clearInterval(state.playInterval);
        state.playInterval = null;
      }
      drawPreview();
    }
    
    // ============================================================================
    // EVENT BINDINGS
    // ============================================================================
    function bindEvents() {
      // Animation selection
      animSelect.onchange = () => {
        state.currentAnim = parseInt(animSelect.value);
        state.currentFrame = 0;
        populateAnimSelect();
        updateFrameStrip();
        draw();
      };
      
      $('#animName').oninput = () => {
        currentAnim().name = $('#animName').value.replace(/\W/g, '');
        populateAnimSelect();
        generateOutput();
      };
      
      $('#animComment').oninput = () => {
        currentAnim().comment = $('#animComment').value;
        generateOutput();
      };
      
      // Add animation
      $('#addAnimBtn').onclick = () => {
        pushHistory();
        const name = prompt('Animation name (e.g. petNewAnim):');
        if (!name) return;
        state.animations.push({
          name: name.replace(/\W/g, ''),
          comment: 'New animation',
          frames: [new Array(state.w * state.h).fill(0)]
        });
        state.currentAnim = state.animations.length - 1;
        state.currentFrame = 0;
        populateAnimSelect();
        updateFrameStrip();
        draw();
        generateOutput();
      };
      
      // Delete animation
      $('#delAnimBtn').onclick = () => {
        if (state.animations.length <= 1) {
          toast('Cannot delete last animation');
          return;
        }
        if (!confirm('Delete animation "' + currentAnim().name + '"?')) return;
        pushHistory();
        state.animations.splice(state.currentAnim, 1);
        state.currentAnim = Math.min(state.currentAnim, state.animations.length - 1);
        state.currentFrame = 0;
        populateAnimSelect();
        updateFrameStrip();
        draw();
        generateOutput();
      };
      
      // Frame management
      $('#addFrameBtn').onclick = () => {
        pushHistory();
        currentAnim().frames.push(new Array(state.w * state.h).fill(0));
        state.currentFrame = currentAnim().frames.length - 1;
        updateFrameStrip();
        draw();
        generateOutput();
      };
      
      $('#dupFrameBtn').onclick = () => {
        pushHistory();
        const copy = currentPixels().slice();
        currentAnim().frames.splice(state.currentFrame + 1, 0, copy);
        state.currentFrame++;
        updateFrameStrip();
        draw();
        generateOutput();
      };
      
      $('#delFrameBtn').onclick = () => {
        if (currentAnim().frames.length <= 1) {
          toast('Cannot delete last frame');
          return;
        }
        pushHistory();
        currentAnim().frames.splice(state.currentFrame, 1);
        state.currentFrame = Math.min(state.currentFrame, currentAnim().frames.length - 1);
        updateFrameStrip();
        draw();
        generateOutput();
      };
      
      $('#moveLeftBtn').onclick = () => {
        if (state.currentFrame === 0) return;
        pushHistory();
        const frames = currentAnim().frames;
        [frames[state.currentFrame - 1], frames[state.currentFrame]] = 
        [frames[state.currentFrame], frames[state.currentFrame - 1]];
        state.currentFrame--;
        updateFrameStrip();
        generateOutput();
      };
      
      $('#moveRightBtn').onclick = () => {
        if (state.currentFrame >= currentAnim().frames.length - 1) return;
        pushHistory();
        const frames = currentAnim().frames;
        [frames[state.currentFrame], frames[state.currentFrame + 1]] = 
        [frames[state.currentFrame + 1], frames[state.currentFrame]];
        state.currentFrame++;
        updateFrameStrip();
        generateOutput();
      };
      
      // Tools
      document.querySelectorAll('[data-tool]').forEach(btn => {
        btn.onclick = () => {
          // Commit any existing selection when switching tools
          if (state.tool === 'select' && selection.floatingPixels) {
            commitSelection();
          }
          document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          state.tool = btn.dataset.tool;
          if (state.tool !== 'select') {
            clearSelection();
          }
          draw();
        };
      });
      
      // Edit buttons
      $('#clearBtn').onclick = clearFrame;
      $('#invertBtn').onclick = invertFrame;
      $('#flipHBtn').onclick = flipH;
      $('#flipVBtn').onclick = flipV;
      $('#undoBtn').onclick = undo;
      $('#redoBtn').onclick = redo;
      
      // Settings
      $('#globalW').onchange = () => {
        pushHistory();
        state.w = Math.max(1, Math.min(64, parseInt($('#globalW').value) || 24));
        resizeCanvas();
        // Resize all frames
        state.animations.forEach(a => {
          a.frames = a.frames.map(f => {
            const newF = new Array(state.w * state.h).fill(0);
            // Copy what fits
            return newF;
          });
        });
        draw();
        generateOutput();
      };
      
      $('#globalH').onchange = () => {
        pushHistory();
        state.h = Math.max(1, Math.min(64, parseInt($('#globalH').value) || 24));
        resizeCanvas();
        draw();
        generateOutput();
      };
      
      $('#zoom').oninput = () => {
        state.zoom = parseInt($('#zoom').value);
        resizeCanvas();
        draw();
      };
      
      // Playback
      $('#playBtn').onclick = playAnimation;
      $('#stopBtn').onclick = stopAnimation;
      $('#speedSlider').oninput = () => {
        state.speed = parseInt($('#speedSlider').value);
        if (state.playing) {
          stopAnimation();
          playAnimation();
        }
      };
      
      // Import/Export
      $('#importFrameBtn').onclick = importFrame;
      
      $('#importFileBtn').onclick = () => $('#fileInput').click();
      $('#fileInput').onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          importPetImagesH(ev.target.result);
        };
        reader.readAsText(file);
      };
      
      $('#exportBtn').onclick = () => {
        generateOutput();
        const blob = new Blob([output.value], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'PetImages.h';
        a.click();
        URL.revokeObjectURL(a.href);
      };
      
      $('#copyBtn').onclick = async () => {
        generateOutput();
        await navigator.clipboard.writeText(output.value);
        toast('Copied to clipboard');
      };
      
      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        // Don't handle shortcuts when typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          // Allow only Escape in inputs
          if (e.key !== 'Escape') return;
        }
        
        const mod = e.ctrlKey || e.metaKey;
        if (mod && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
        else if (mod && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); redo(); }
        else if (mod && e.key === 'c') {
          // Copy selection
          if (selection.active) {
            e.preventDefault();
            copySelection();
          }
        }
        else if (mod && e.key === 'x') {
          // Cut selection
          if (selection.active) {
            e.preventDefault();
            cutSelection();
          }
        }
        else if (mod && e.key === 'v') {
          // Let the paste event handler deal with it - it will check for images
          // and fall back to internal clipboard if appropriate
        }
        else if (e.key === 'Escape') {
          // Cancel selection or commit it
          if (selection.floatingPixels) {
            commitSelection();
          } else {
            clearSelection();
          }
          draw();
        }
        else if (e.key === 'Delete' || e.key === 'Backspace') {
          // Delete selected pixels
          if (selection.active) {
            e.preventDefault();
            pushHistory();
            if (selection.floatingPixels) {
              // Delete floating selection
              selection.floatingPixels = null;
            } else {
              // Delete pixels in selection area
              const minX = Math.min(selection.startX, selection.endX);
              const minY = Math.min(selection.startY, selection.endY);
              const maxX = Math.max(selection.startX, selection.endX);
              const maxY = Math.max(selection.startY, selection.endY);
              const pixels = currentPixels();
              for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                  if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                    pixels[y * state.w + x] = 0;
                  }
                }
              }
            }
            clearSelection();
            draw();
            generateOutput();
          }
        }
      });
      
      // Clipboard paste handler for images
      window.addEventListener('paste', async (e) => {
        // Skip if typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          return;
        }
        
        // Check for image in clipboard - if there's an image, it's from external source
        const items = e.clipboardData?.items || [];
        for (const item of items) {
          if (item.type.startsWith('image/')) {
            e.preventDefault();
            const blob = item.getAsFile();
            await processClipboardImage(blob);
            return;
          }
        }
        
        // No image in clipboard - paste from internal clipboard if available
        if (internalClipboard) {
          e.preventDefault();
          pasteFromInternalClipboard();
        }
      });
      
      // Clipboard modal events
      $('#thresholdSlider').oninput = () => {
        clipboardThreshold = parseInt($('#thresholdSlider').value);
        $('#thresholdValue').textContent = clipboardThreshold;
        updateClipboardPreview();
      };
      
      $('#invertImport').onchange = () => {
        clipboardInvert = $('#invertImport').checked;
        updateClipboardPreview();
      };
      
      $('#cancelClipboard').onclick = hideClipboardModal;
      $('#applyClipboard').onclick = applyClipboardToFrame;
      $('#pasteImageBtn').onclick = async () => {
        // Try to read image from system clipboard
        try {
          const items = await navigator.clipboard.read();
          for (const item of items) {
            for (const type of item.types) {
              if (type.startsWith('image/')) {
                const blob = await item.getType(type);
                await processClipboardImage(blob);
                return;
              }
            }
          }
          toast('No image in clipboard');
        } catch (err) {
          toast('Clipboard access denied - use Ctrl+V');
        }
      };
      
      // Close modal on overlay click
      $('#clipboardModal').onclick = (e) => {
        if (e.target === $('#clipboardModal')) {
          hideClipboardModal();
        }
      };
    }
    
    // Toast notification
    function toast(msg) {
      const t = document.createElement('div');
      t.textContent = msg;
      t.style.cssText = 'position:fixed;bottom:16px;right:16px;background:#1f2534;border:1px solid #2e3952;padding:10px 12px;border-radius:10px;color:#d3dbeb;box-shadow:0 10px 30px rgba(0,0,0,.25);z-index:9999';
      document.body.appendChild(t);
      setTimeout(() => {
        t.style.transition = 'all .3s ease';
        t.style.opacity = '0';
        t.style.transform = 'translateY(8px)';
        setTimeout(() => t.remove(), 300);
      }, 1500);
    }
    
    // Start
    init();
  </script>
</body>
</html>
