<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bitmap Emote Editor ‚Äî Clean Layout</title>
  <style>
    :root{
      --bg:#0f1115;--panel:#161a23;--panel-2:#1e2430;--text:#e5e9f0;--muted:#9aa4b2;--accent:#7c90ff;--grid:#2a3140;--on:#e5e9f0;--off:#0f1115;
      --danger:#ff6b6b;--ok:#22c55e;--warn:#f59e0b;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0f1115,#121624 60%);color:var(--text);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;background:var(--panel);border-bottom:1px solid #232a3a;gap:10px;flex-wrap:wrap}
    h1{font-size:18px;margin:0;font-weight:700;letter-spacing:.2px}
    .wrap{display:grid;grid-template-columns:var(--left-width, 280px) 6px 1fr 6px var(--right-width, 320px);gap:0;padding:14px;min-height:calc(100vh - 60px)}
    .col{display:grid;gap:14px;align-content:start;padding:0 8px}
    .col:first-child{padding-left:0}
    .col:last-child{padding-right:0}
    .center-card{padding:0 8px}
    /* Resize handles */
    .resize-handle{width:6px;background:transparent;cursor:col-resize;position:relative;transition:background 0.15s}
    .resize-handle:hover,.resize-handle.dragging{background:#3a4a6a}
    .resize-handle::after{content:'';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:2px;height:40px;background:#3a4a6a;border-radius:2px;opacity:0.5}
    .resize-handle:hover::after,.resize-handle.dragging::after{opacity:1;background:var(--accent)}
    .card{background:var(--panel);border:1px solid #222a3a;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);}
    .card h2{font-size:13px;font-weight:700;margin:0;padding:10px 14px;border-bottom:1px solid #222a3a;color:#cbd5e1;display:flex;align-items:center;gap:8px}
    .card .body{padding:12px 14px}
    label{display:block;font-size:11px;color:var(--muted);margin:8px 0 4px}
    input[type="number"], input[type="text"], select, textarea{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #243048;background:var(--panel-2);color:var(--text);font-family:inherit;font-size:12px}
    textarea{min-height:200px;resize:vertical}
    .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{appearance:none;border:1px solid #2b3650;background: #202635;color:var(--text);padding:8px 12px;border-radius:12px;font-weight:600;font-size:12px;cursor:pointer}
    .btn:hover{filter:brightness(1.15)}
    .btn.primary{background:linear-gradient(180deg,#6378ff,#5a6df8);border-color:#5461de;color:white}
    .btn.ghost{background:transparent;border-color:#303a57}
    .btn.warn{background:#3b2a12;border-color:#5d3d12;color:#ffd68a}
    .btn.danger{background:#3c1c1c;border-color:#5b2323;color:#ffb4b4}
    .gridWrap{display:flex;gap:16px;align-items:flex-start;flex-wrap:wrap}
    canvas{background:var(--off);border:1px solid #252c3e;border-radius:12px;image-rendering:pixelated;cursor:crosshair}
    .legend{font-size:12px;color:var(--muted)}
    .pill{display:inline-flex;align-items:center;gap:8px;border:1px dashed #334057;padding:8px 10px;border-radius:12px;background:#121827;color:#aab3c2;font-size:12px}
    .switch{display:inline-flex;align-items:center;gap:6px}
    .footer{padding:10px 14px;border-top:1px solid #222a3a;color:#9aa4b2;font-size:12px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    /* nicer import layout */
    .import-grid{display:grid;grid-template-columns:1fr;gap:10px}
    
    /* Selection overlay */
    .selection-overlay{position:absolute;border:2px dashed var(--accent);background:rgba(124,144,255,0.1);pointer-events:none;box-sizing:border-box}
    .canvas-wrapper{position:relative;display:inline-block}
    canvas.move-cursor{cursor:move}
    
    /* Clipboard import modal */
    .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:1000}
    .modal-overlay.active{display:flex}
    .modal{background:var(--panel);border:1px solid #222a3a;border-radius:16px;padding:20px;max-width:500px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,.4)}
    .modal h3{margin:0 0 15px;font-size:16px;color:var(--text)}
    .modal-preview{display:flex;gap:15px;margin:15px 0}
    .modal-preview canvas{border:1px solid #2a3a50;border-radius:8px;image-rendering:pixelated}
    .modal-preview-label{font-size:11px;color:var(--muted);margin-bottom:5px}
    .modal-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:15px}
    .threshold-control{margin:10px 0}
    .threshold-control label{display:flex;align-items:center;gap:10px}
    .threshold-control input[type="range"]{flex:1}
    .btn.small{padding:5px 8px;font-size:11px}
    .btn.active{background:#2d3a5a;border-color:var(--accent)}
    
    /* Tool tiles */
    .tool-grid{display:flex;flex-wrap:wrap;gap:6px;margin:8px 0}
    .tool-tile{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:8px 6px;border:1px solid #2b3650;background:#202635;border-radius:10px;cursor:pointer;transition:all 0.15s ease;flex:1 1 50px;min-width:50px;max-width:80px}
    .tool-tile:hover{background:#2a3448;border-color:#3a4a6a}
    .tool-tile.active{background:#2d3a5a;border-color:var(--accent);box-shadow:0 0 8px rgba(124,144,255,0.3)}
    .tool-tile .icon{font-size:18px;line-height:1;margin-bottom:4px}
    .tool-tile .label{font-size:9px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px;white-space:nowrap}
    .tool-tile.active .label{color:var(--accent)}
    .tool-tile .sublabel{font-size:7px;color:var(--muted);opacity:0.7;white-space:nowrap}

    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr !important}
      .resize-handle{display:none}
      .col{padding:0 !important}
    }
  </style>
</head>
<body>
  <header>
    <h1>üß© Bitmap Emote Editor</h1>
    <div class="row">
      <a href="animation_editor.html" class="btn ghost">üêæ Animation Editor</a>
    </div>
  </header>

  <div class="wrap">
    <!-- Left column: Emotes list + Tools -->
    <div class="col" id="leftCol">
      <section class="card">
        <h2>üé® Emotes</h2>
        <div class="body">
          <div class="row" style="margin-bottom:10px">
            <select id="emoteSelect" style="flex:1"></select>
            <button class="btn small" id="addEmoteBtn">+ Add</button>
            <button class="btn small danger" id="delEmoteBtn">Delete</button>
          </div>
          <label>Emote Name (C identifier)</label>
          <input type="text" id="name" class="mono" placeholder="e.g. heart"/>
          <label>Unicode Symbols (comma-separated)</label>
          <input id="symbol" type="text" placeholder="e.g. ‚ù§Ô∏è, üíï, ‚ô•Ô∏è"/>
          <div class="controls" style="margin-top:10px">
            <div>
              <label>Width</label>
              <input type="number" id="w" value="16" min="1" max="128"/>
            </div>
            <div>
              <label>Height</label>
              <input type="number" id="h" value="16" min="1" max="128"/>
            </div>
          </div>
        </div>
      </section>

      <section class="card">
        <h2>üîß Tools</h2>
        <div class="body">
          <div class="tool-grid">
            <div class="tool-tile active" data-tool="draw" data-toggle="draw"><span class="icon">‚úèÔ∏è</span><span class="label">Draw</span><span class="sublabel">L/R swap</span></div>
            <div class="tool-tile" data-tool="line"><span class="icon">üìè</span><span class="label">Line</span></div>
            <div class="tool-tile" data-tool="rect" data-toggle="rect"><span class="icon">‚¨ú</span><span class="label">Rect</span><span class="sublabel">outline</span></div>
            <div class="tool-tile" data-tool="circle" data-toggle="circle"><span class="icon">‚≠ï</span><span class="label">Circle</span><span class="sublabel">outline</span></div>
            <div class="tool-tile" data-tool="fill"><span class="icon">ü™£</span><span class="label">Fill</span></div>
            <div class="tool-tile" data-tool="select"><span class="icon">‚¨ö</span><span class="label">Select</span></div>
          </div>
        </div>
      </section>

      <section class="card">
        <h2>‚öôÔ∏è Settings</h2>
        <div class="body">
          <div class="row">
            <span class="pill"><input id="gridToggle" type="checkbox" checked> <span>Grid</span></span>
            <span class="pill"><input id="dragToggle" type="checkbox" checked> <span>Drag draw</span></span>
          </div>
          <label>Zoom</label>
          <input type="range" id="zoom" min="8" max="32" value="16"/>
          <div style="height:8px"></div>
          <label>Bit Packing</label>
          <select id="bitOrder">
            <option value="lsb0" selected>LSB first (bit0=leftmost)</option>
            <option value="msb0">MSB first (bit7=leftmost)</option>
          </select>
          <div style="height:8px"></div>
          <div class="row">
            <span class="pill"><input id="padRows" type="checkbox" checked> <span>Pad rows</span></span>
            <span class="pill"><input id="progmem" type="checkbox" checked> <span>PROGMEM</span></span>
          </div>
        </div>
      </section>
    </div>

    <!-- Left resize handle -->
    <div class="resize-handle" id="leftResizeHandle"></div>

    <!-- Center: Editor -->
    <section class="card">
      <h2>‚úèÔ∏è Editor</h2>
      <div class="body">
        <div class="row" style="margin-bottom:10px">
          <button class="btn small" id="clearBtn">Clear</button>
          <button class="btn small" id="invertBtn">Invert</button>
          <button class="btn small" id="flipHBtn">Flip H</button>
          <button class="btn small" id="flipVBtn">Flip V</button>
          <button class="btn small" id="rotLBtn">‚Ü∫</button>
          <button class="btn small" id="rotRBtn">‚Üª</button>
          <button class="btn small" id="undoBtn">Undo</button>
          <button class="btn small" id="redoBtn">Redo</button>
        </div>
        <div class="canvas-wrapper" id="canvasWrapper">
          <canvas id="grid" width="384" height="384"></canvas>
          <div class="selection-overlay" id="selectionOverlay" style="display:none"></div>
        </div>
        <div class="legend" style="margin-top:10px">Left‚Äëclick: draw ‚Ä¢ Right‚Äëclick: erase ‚Ä¢ Ctrl+C/X/V: copy/cut/paste</div>
      </div>
    </section>

    <!-- Right resize handle -->
    <div class="resize-handle" id="rightResizeHandle"></div>

    <!-- Right column: Preview + Import/Export -->
    <div class="col" id="rightCol">
      <section class="card">
        <h2>üëÅÔ∏è Preview</h2>
        <div class="body" style="text-align:center">
          <canvas id="preview" width="96" height="96" style="border:1px dashed #2c3346;border-radius:10px"></canvas>
        </div>
      </section>

      <section class="card">
        <h2>üì• Import</h2>
        <div class="body">
          <div class="row" style="margin-bottom:10px">
            <button class="btn small" id="importFileBtn" style="flex:1">üìÇ Import emotes.cpp</button>
          </div>
          <label>Or paste hex bytes</label>
          <textarea id="in" class="mono" style="min-height:50px" placeholder="0x00, 0x1C, ..."></textarea>
          <div class="controls" style="margin-top:8px">
            <div>
              <label>Width</label>
              <input type="number" id="iw" min="1" max="256" placeholder="16"/>
            </div>
            <div>
              <label>Height</label>
              <input type="number" id="ih" min="1" max="256" placeholder="16"/>
            </div>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="importBtn" class="btn small">Import Hex</button>
            <button id="pasteImageBtn" class="btn small">üìã Paste Image</button>
          </div>
        </div>
      </section>

      <section class="card" style="flex:1">
        <h2>üì§ Export</h2>
        <div class="body">
          <textarea id="out" class="mono" style="min-height:150px" spellcheck="false" placeholder="// Generated code will appear here..."></textarea>
          <div class="row" style="margin-top:8px">
            <button class="btn small" id="exportBtn">Generate</button>
            <button class="btn small" id="copyBtn">Copy</button>
          </div>
          <div class="row" style="margin-top:8px">
            <button class="btn small primary" id="exportFileBtn" style="flex:1">üìÇ Export .h + .cpp</button>
          </div>
          <div class="row" style="margin-top:8px">
            <button class="btn small" id="copyAllBtn" style="flex:1">üìã Copy All Emotes</button>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Clipboard Import Modal -->
  <div class="modal-overlay" id="clipboardModal">
    <div class="modal">
      <h3>üìã Import Image from Clipboard</h3>
      <div class="modal-preview">
        <div>
          <div class="modal-preview-label">Original</div>
          <canvas id="clipboardOriginal" width="96" height="96"></canvas>
        </div>
        <div>
          <div class="modal-preview-label">Binary Preview (<span id="previewSize"></span>)</div>
          <canvas id="clipboardBinary" width="96" height="96"></canvas>
        </div>
      </div>
      <div class="threshold-control">
        <label>
          <span style="font-size:12px;min-width:70px">Threshold:</span>
          <input type="range" id="thresholdSlider" min="0" max="255" value="128"/>
          <span id="thresholdValue" style="font-size:12px;min-width:30px">128</span>
        </label>
      </div>
      <div class="threshold-control">
        <label>
          <input type="checkbox" id="invertImport"/>
          <span style="font-size:12px">Invert colors</span>
        </label>
      </div>
      <div class="legend" style="margin:8px 0">Image will be pasted at original size as a movable selection.</div>
      <div class="modal-actions">
        <button class="btn" id="cancelClipboard">Cancel</button>
        <button class="btn primary" id="applyClipboard">Paste as Selection</button>
      </div>
    </div>
  </div>

  <script>
    // --- Model ---
    const state = {
      w: 16, h: 16,
      pixels: [],
      zoom: 16,
      brush: 'draw',
      gridLines: true,
      dragToDraw: true,
      drawInverted: false,  // When true, left click erases, right click draws
      rectFilled: false,    // Toggle for filled rectangle
      circleFilled: false,  // Toggle for filled circle
    };

    // Emotes list - each emote stores its own pixel data
    let emotes = [
      { name: 'heart', symbols: ['‚ù§Ô∏è'], w: 16, h: 16, pixels: new Array(16*16).fill(0) }
    ];
    let currentEmote = 0;

    // Selection state
    let selection = {
      active: false,
      startX: 0, startY: 0,
      endX: 0, endY: 0,
      dragging: false,
      dragOffsetX: 0, dragOffsetY: 0,
      floatingPixels: null
    };

    // Clipboard state
    let internalClipboard = null;
    let clipboardImage = null;
    let clipboardThreshold = 128;
    let clipboardInvert = false;

    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    // Elements
    const grid = $('#grid');
    const g = grid.getContext('2d');
    const preview = $('#preview');
    const gp = preview.getContext('2d');

    const wIn = $('#w');
    const hIn = $('#h');
    const zoomIn = $('#zoom');
    const gridToggle = $('#gridToggle');
    const dragToggle = $('#dragToggle');

    const out = $('#out');
    const nameIn = $('#name');
    const symbolIn = $('#symbol');
    const emoteSelect = $('#emoteSelect');

    const bitOrder = $('#bitOrder');
    const padRows = $('#padRows');
    const progmem = $('#progmem');

    const importArea = $('#in');
    const iw = $('#iw');
    const ih = $('#ih');
    const selectionOverlay = $('#selectionOverlay');

    // --- Emote Management ---
    function currentEmoteObj() {
      return emotes[currentEmote];
    }

    function saveCurrentEmote() {
      // Save current state back to the emote object
      const e = emotes[currentEmote];
      e.pixels = state.pixels.slice();
      e.w = state.w;
      e.h = state.h;
      e.name = nameIn.value || 'emote';
      // Parse symbols: split by comma, trim whitespace, filter empty
      e.symbols = symbolIn.value.split(',').map(s => s.trim()).filter(s => s);
    }

    function loadEmote(index) {
      currentEmote = Math.max(0, Math.min(index, emotes.length - 1));
      const e = emotes[currentEmote];
      state.w = e.w;
      state.h = e.h;
      state.pixels = e.pixels.slice();
      wIn.value = state.w;
      hIn.value = state.h;
      nameIn.value = e.name;
      // Display symbols array as comma-separated (handle legacy single symbol)
      symbolIn.value = Array.isArray(e.symbols) ? e.symbols.join(', ') : (e.symbol || '');
      resizeCanvas();
      draw();
    }

    function populateEmoteSelect() {
      emoteSelect.innerHTML = emotes.map((e, i) => 
        `<option value="${i}">${e.name} (${e.w}x${e.h})</option>`
      ).join('');
      emoteSelect.value = currentEmote;
    }

    function addEmote() {
      saveCurrentEmote();
      const name = prompt('Emote name (C identifier):', 'newEmote');
      if (!name) return;
      emotes.push({
        name: name.replace(/\W/g, ''),
        symbols: [],
        w: 16,
        h: 16,
        pixels: new Array(16 * 16).fill(0)
      });
      currentEmote = emotes.length - 1;
      populateEmoteSelect();
      loadEmote(currentEmote);
    }

    function deleteEmote() {
      if (emotes.length <= 1) {
        toast('Cannot delete last emote');
        return;
      }
      if (!confirm('Delete emote "' + currentEmoteObj().name + '"?')) return;
      pushHistory();
      emotes.splice(currentEmote, 1);
      currentEmote = Math.min(currentEmote, emotes.length - 1);
      populateEmoteSelect();
      loadEmote(currentEmote);
    }

    // History stacks
    const undoStack = [];
    const redoStack = [];
    const MAX_HISTORY = 100;

    function snapshot(){
      return { w: state.w, h: state.h, pixels: state.pixels.slice() };
    }
    function pushHistory(){
      undoStack.push(snapshot());
      if (undoStack.length > MAX_HISTORY) undoStack.shift();
      // any new action invalidates redo chain
      redoStack.length = 0;
    }
    function restore(snap){
      // restore without creating a new history node
      setSize(snap.w, snap.h, /*noDraw*/ true);
      state.pixels = snap.pixels.slice();
      draw();
    }
    function undo(){
      if(!undoStack.length) { toast('Nothing to undo'); return; }
      const current = snapshot();
      const prev = undoStack.pop();
      redoStack.push(current);
      restore(prev);
    }
    function redo(){
      if(!redoStack.length) { toast('Nothing to redo'); return; }
      const current = snapshot();
      const next = redoStack.pop();
      undoStack.push(current);
      restore(next);
    }

    // Buttons
    $('#clearBtn').onclick = () => { pushHistory(); clearPixels(); draw(); };
    $('#invertBtn').onclick = () => { pushHistory(); invertPixels(); draw(); };
    $('#flipHBtn').onclick = () => { pushHistory(); flipHorizontal(); draw(); };
    $('#flipVBtn').onclick = () => { pushHistory(); flipVertical(); draw(); };
    $('#rotLBtn').onclick = () => { pushHistory(); rotateSelection(-90); draw(); };
    $('#rotRBtn').onclick = () => { pushHistory(); rotateSelection(90); draw(); };
    $('#undoBtn').onclick = () => undo();
    $('#redoBtn').onclick = () => redo();

    // Emote management buttons
    emoteSelect.onchange = () => {
      saveCurrentEmote();
      loadEmote(+emoteSelect.value);
    };
    $('#addEmoteBtn').onclick = addEmote;
    $('#delEmoteBtn').onclick = deleteEmote;

    // Name/symbol inputs save to current emote
    nameIn.oninput = () => {
      emotes[currentEmote].name = nameIn.value;
      populateEmoteSelect();
    };
    symbolIn.oninput = () => {
      emotes[currentEmote].symbols = symbolIn.value.split(',').map(s => s.trim()).filter(s => s);
    };

    // Header buttons - file import/export
    $('#importFileBtn').onclick = () => importEmotesFile();
    $('#exportFileBtn').onclick = () => exportEmotesFile();
    $('#copyAllBtn').onclick = async () => {
      saveCurrentEmote();
      const code = generateAllEmotesCode();
      await navigator.clipboard.writeText(code);
      toast('All emotes copied to clipboard');
    };

    // Single emote output buttons
    $('#exportBtn').onclick = () => {
      out.value = makeCArray();
      out.scrollTop = 0;
    };
    $('#copyBtn').onclick = async () => {
      if(!out.value) out.value = makeCArray();
      await navigator.clipboard.writeText(out.value);
      toast('Copied to clipboard');
    };

    // Legacy single-emote buttons (keep for Import Single section)
    $('#importBtn').onclick = () => { pushHistory(); importFromHex(); };
    // Inputs
    wIn.oninput = () => { pushHistory(); setSize(+wIn.value, state.h); saveCurrentEmote(); };
    hIn.oninput = () => { pushHistory(); setSize(state.w, +hIn.value); saveCurrentEmote(); };
    zoomIn.oninput = () => { state.zoom = +zoomIn.value; resizeCanvas(); draw(); };
    
    // Tool tile click handlers with toggle support
    $$('[data-tool]').forEach(tile => {
      tile.onclick = () => {
        const newTool = tile.dataset.tool;
        const toggleType = tile.dataset.toggle;
        
        // Handle toggle tools when clicking the same tool again
        if (state.brush === newTool && toggleType) {
          if (toggleType === 'draw') {
            state.drawInverted = !state.drawInverted;
            const sublabel = tile.querySelector('.sublabel');
            sublabel.textContent = state.drawInverted ? 'inverted' : 'L/R swap';
            toast(state.drawInverted ? 'Draw mode: Right=draw, Left=erase' : 'Draw mode: Left=draw, Right=erase');
          } else if (toggleType === 'rect') {
            state.rectFilled = !state.rectFilled;
            const icon = tile.querySelector('.icon');
            const sublabel = tile.querySelector('.sublabel');
            icon.textContent = state.rectFilled ? '‚¨õ' : '‚¨ú';
            sublabel.textContent = state.rectFilled ? 'filled' : 'outline';
            toast(state.rectFilled ? 'Rectangle: filled' : 'Rectangle: outline');
          } else if (toggleType === 'circle') {
            state.circleFilled = !state.circleFilled;
            const icon = tile.querySelector('.icon');
            const sublabel = tile.querySelector('.sublabel');
            icon.textContent = state.circleFilled ? 'üîµ' : '‚≠ï';
            sublabel.textContent = state.circleFilled ? 'filled' : 'outline';
            toast(state.circleFilled ? 'Circle: filled' : 'Circle: outline');
          }
          return;
        }
        
        // Commit selection when switching away from select tool
        if (state.brush === 'select' && newTool !== 'select') {
          if (selection.floatingPixels) { commitSelection(); }
          else { clearSelection(); }
        }
        state.brush = newTool;
        $$('[data-tool]').forEach(t => t.classList.remove('active'));
        tile.classList.add('active');
        draw();
      };
    });
    
    gridToggle.oninput = () => { state.gridLines = gridToggle.checked; draw(); };
    dragToggle.oninput = () => { state.dragToDraw = dragToggle.checked; };

    // Keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      // Don't handle shortcuts when typing in inputs
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        if (e.key !== 'Escape') return;
      }
      
      const key = e.key.toLowerCase();
      const mod = e.ctrlKey || e.metaKey;
      if(mod && key === 'z' && !e.shiftKey){ e.preventDefault(); undo(); }
      else if( (mod && key === 'y') || (mod && key === 'z' && e.shiftKey) ) { e.preventDefault(); redo(); }
      else if (mod && key === 'c') {
        if (selection.active) { e.preventDefault(); copySelection(); }
      }
      else if (mod && key === 'x') {
        if (selection.active) { e.preventDefault(); cutSelection(); }
      }
      else if (mod && key === 'v') {
        // Let paste event handle it
      }
      else if (e.key === 'Escape') {
        if (selection.floatingPixels) { commitSelection(); }
        else { clearSelection(); }
        draw();
      }
      else if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selection.active) {
          e.preventDefault();
          pushHistory();
          if (selection.floatingPixels) {
            selection.floatingPixels = null;
          } else {
            const minX = Math.min(selection.startX, selection.endX);
            const minY = Math.min(selection.startY, selection.endY);
            const maxX = Math.max(selection.startX, selection.endX);
            const maxY = Math.max(selection.startY, selection.endY);
            for (let y = minY; y <= maxY; y++) {
              for (let x = minX; x <= maxX; x++) {
                if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                  state.pixels[y * state.w + x] = 0;
                }
              }
            }
          }
          clearSelection();
          draw();
        }
      }
    });
    
    // Clipboard paste handler
    window.addEventListener('paste', async (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      const items = e.clipboardData?.items || [];
      for (const item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const blob = item.getAsFile();
          await processClipboardImage(blob);
          return;
        }
      }
      
      if (internalClipboard) {
        e.preventDefault();
        pasteFromInternalClipboard();
      }
    });

    // init
    populateEmoteSelect();
    loadEmote(0);

    // --- Drawing helpers ---
    function setSize(w,h,noDraw=false){
      state.w = Math.max(1, Math.min(128, w|0));
      state.h = Math.max(1, Math.min(128, h|0));
      wIn.value = state.w; hIn.value = state.h;
      resizeCanvas();
      // keep data, cropping or padding as needed
      const next = new Array(state.w*state.h).fill(0);
      for(let y=0;y<Math.min(state.h, pixelsH());y++){
        for(let x=0;x<Math.min(state.w, pixelsW());x++){
          next[y*state.w + x] = state.pixels[y*pixelsW()+x]||0;
        }
      }
      state.pixels = next;
      if(!noDraw) draw();
    }
    function pixelsW(){ return state._pw || state.w; }
    function pixelsH(){ return state._ph || state.h; }

    function clearPixels(){ state.pixels = new Array(state.w*state.h).fill(0); }
    function mapPixels(fn){ state.pixels = state.pixels.map(fn); }

    // Selection-aware transforms
    function invertPixels() {
      if (selection.active) {
        if (selection.floatingPixels) {
          for (let dy = 0; dy < selection.floatingPixels.length; dy++) {
            for (let dx = 0; dx < selection.floatingPixels[dy].length; dx++) {
              selection.floatingPixels[dy][dx] = selection.floatingPixels[dy][dx] ? 0 : 1;
            }
          }
        } else {
          const minX = Math.min(selection.startX, selection.endX);
          const minY = Math.min(selection.startY, selection.endY);
          const maxX = Math.max(selection.startX, selection.endX);
          const maxY = Math.max(selection.startY, selection.endY);
          for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
              if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                const i = y * state.w + x;
                state.pixels[i] = state.pixels[i] ? 0 : 1;
              }
            }
          }
        }
      } else {
        mapPixels(v => v ? 0 : 1);
      }
    }

    function flipHorizontal() {
      if (selection.active) {
        if (selection.floatingPixels) {
          selection.floatingPixels = selection.floatingPixels.map(row => [...row].reverse());
        } else {
          const minX = Math.min(selection.startX, selection.endX);
          const minY = Math.min(selection.startY, selection.endY);
          const maxX = Math.max(selection.startX, selection.endX);
          const maxY = Math.max(selection.startY, selection.endY);
          for (let y = minY; y <= maxY; y++) {
            const row = [];
            for (let x = minX; x <= maxX; x++) {
              row.push(x >= 0 && x < state.w && y >= 0 && y < state.h ? state.pixels[y * state.w + x] : 0);
            }
            row.reverse();
            for (let x = minX; x <= maxX; x++) {
              if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                state.pixels[y * state.w + x] = row[x - minX];
              }
            }
          }
        }
      } else {
        flip(true, false);
      }
    }

    function flipVertical() {
      if (selection.active) {
        if (selection.floatingPixels) {
          selection.floatingPixels = [...selection.floatingPixels].reverse();
        } else {
          const minX = Math.min(selection.startX, selection.endX);
          const minY = Math.min(selection.startY, selection.endY);
          const maxX = Math.max(selection.startX, selection.endX);
          const maxY = Math.max(selection.startY, selection.endY);
          const temp = [];
          for (let y = minY; y <= maxY; y++) {
            temp[y - minY] = [];
            for (let x = minX; x <= maxX; x++) {
              temp[y - minY][x - minX] = x >= 0 && x < state.w && y >= 0 && y < state.h ? state.pixels[y * state.w + x] : 0;
            }
          }
          for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
              if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
                state.pixels[y * state.w + x] = temp[maxY - y][x - minX];
              }
            }
          }
        }
      } else {
        flip(false, true);
      }
    }

    function rotateSelection(deg) {
      if (selection.active && selection.floatingPixels) {
        const times = ((deg % 360) + 360) % 360 / 90 | 0;
        for (let t = 0; t < times; t++) {
          const H = selection.floatingPixels.length;
          const W = selection.floatingPixels[0].length;
          const newPixels = [];
          for (let y = 0; y < W; y++) {
            newPixels[y] = [];
            for (let x = 0; x < H; x++) {
              newPixels[y][x] = selection.floatingPixels[H - 1 - x][y];
            }
          }
          selection.floatingPixels = newPixels;
          selection.endX = selection.startX + newPixels[0].length - 1;
          selection.endY = selection.startY + newPixels.length - 1;
        }
      } else if (selection.active) {
        // Rotate pixels within marquee selection
        const minX = Math.min(selection.startX, selection.endX);
        const minY = Math.min(selection.startY, selection.endY);
        const maxX = Math.max(selection.startX, selection.endX);
        const maxY = Math.max(selection.startY, selection.endY);
        const W = maxX - minX + 1;
        const H = maxY - minY + 1;
        
        // Extract pixels from selection
        let pixels = [];
        for (let y = 0; y < H; y++) {
          pixels[y] = [];
          for (let x = 0; x < W; x++) {
            const px = minX + x, py = minY + y;
            pixels[y][x] = (px >= 0 && px < state.w && py >= 0 && py < state.h) ? state.pixels[py * state.w + px] : 0;
          }
        }
        
        // Rotate the extracted pixels
        const times = ((deg % 360) + 360) % 360 / 90 | 0;
        for (let t = 0; t < times; t++) {
          const oldH = pixels.length;
          const oldW = pixels[0].length;
          const newPixels = [];
          for (let y = 0; y < oldW; y++) {
            newPixels[y] = [];
            for (let x = 0; x < oldH; x++) {
              newPixels[y][x] = pixels[oldH - 1 - x][y];
            }
          }
          pixels = newPixels;
        }
        
        // Clear original selection area
        for (let y = minY; y <= maxY; y++) {
          for (let x = minX; x <= maxX; x++) {
            if (x >= 0 && x < state.w && y >= 0 && y < state.h) {
              state.pixels[y * state.w + x] = 0;
            }
          }
        }
        
        // Write rotated pixels back (centered at same position)
        const newH = pixels.length;
        const newW = pixels[0].length;
        for (let y = 0; y < newH; y++) {
          for (let x = 0; x < newW; x++) {
            const px = minX + x, py = minY + y;
            if (px >= 0 && px < state.w && py >= 0 && py < state.h) {
              state.pixels[py * state.w + px] = pixels[y][x];
            }
          }
        }
        
        // Update selection bounds
        selection.startX = minX;
        selection.startY = minY;
        selection.endX = minX + newW - 1;
        selection.endY = minY + newH - 1;
      } else {
        rotate(deg);
      }
    }

    function flip(h,v){
      const out = new Array(state.w*state.h).fill(0);
      for(let y=0;y<state.h;y++){
        for(let x=0;x<state.w;x++){
          const sx = h ? (state.w-1-x) : x;
          const sy = v ? (state.h-1-y) : y;
          out[y*state.w+x] = state.pixels[sy*state.w+sx];
        }
      }
      state.pixels = out;
    }

    function rotate(deg){
      const times = ((deg%360)+360)%360/90|0; // 0..3
      for(let t=0;t<times;t++){
        const out = new Array(state.w*state.h).fill(0);
        const W=state.w, H=state.h;
        for(let y=0;y<H;y++) for(let x=0;x<W;x++){
          const nx = H-1-y, ny = x;
          out[ny*H + nx] = state.pixels[y*W + x];
        }
        state.pixels = out; state.w = H; state.h = W; wIn.value=state.w; hIn.value=state.h; resizeCanvas();
      }
    }

    function resizeCanvas(){
      grid.width = state.w*state.zoom; grid.height = state.h*state.zoom;
    }

    function draw(){
      const z = state.zoom;
      g.fillStyle = '#0b0e16';
      g.fillRect(0,0,grid.width,grid.height);
      for(let y=0;y<state.h;y++){
        for(let x=0;x<state.w;x++){
          const v = state.pixels[y*state.w+x];
          g.fillStyle = v? 'white':'#0f1115';
          g.fillRect(x*z, y*z, z, z);
        }
      }
      
      // Draw floating selection pixels
      if (selection.floatingPixels && selection.active) {
        for (let dy = 0; dy < selection.floatingPixels.length; dy++) {
          for (let dx = 0; dx < selection.floatingPixels[dy].length; dx++) {
            const px = selection.startX + dx;
            const py = selection.startY + dy;
            if (px >= 0 && px < state.w && py >= 0 && py < state.h) {
              if (selection.floatingPixels[dy][dx]) {
                g.fillStyle = '#7cffb0';
                g.fillRect(px * z, py * z, z, z);
              }
            }
          }
        }
      }
      
      if(state.gridLines){
        g.strokeStyle = '#2b3245'; g.lineWidth = 1; g.beginPath();
        for(let x=0;x<=state.w;x++){ g.moveTo(x*z+0.5,0); g.lineTo(x*z+0.5,grid.height); }
        for(let y=0;y<=state.h;y++){ g.moveTo(0,y*z+0.5); g.lineTo(grid.width,y*z+0.5); }
        g.stroke();
      }
      
      // Draw selection overlay
      drawSelectionOverlay();
      
      // preview
      const P = Math.max(1, Math.floor(120 / Math.max(state.w,state.h)));
      preview.width = state.w*P; preview.height = state.h*P;
      gp.fillStyle = '#0f1115'; gp.fillRect(0,0,preview.width,preview.height);
      for(let y=0;y<state.h;y++) for(let x=0;x<state.w;x++){
        gp.fillStyle = state.pixels[y*state.w+x]? '#e5e9f0':'#0f1115';
        gp.fillRect(x*P,y*P,P,P);
      }
    }
    
    function drawSelectionOverlay() {
      if (!selection.active || state.brush !== 'select') {
        selectionOverlay.style.display = 'none';
        return;
      }
      
      const z = state.zoom;
      let minX, minY, width, height;
      
      if (selection.floatingPixels) {
        minX = selection.startX;
        minY = selection.startY;
        width = selection.floatingPixels[0].length;
        height = selection.floatingPixels.length;
      } else {
        minX = Math.min(selection.startX, selection.endX);
        minY = Math.min(selection.startY, selection.endY);
        width = Math.abs(selection.endX - selection.startX) + 1;
        height = Math.abs(selection.endY - selection.startY) + 1;
      }
      
      selectionOverlay.style.display = 'block';
      selectionOverlay.style.left = (minX * z) + 'px';
      selectionOverlay.style.top = (minY * z) + 'px';
      selectionOverlay.style.width = (width * z) + 'px';
      selectionOverlay.style.height = (height * z) + 'px';
    }
    
    // Selection functions
    function isInsideSelection(x, y) {
      if (!selection.active) return false;
      let minX, minY, maxX, maxY;
      if (selection.floatingPixels) {
        minX = selection.startX;
        minY = selection.startY;
        maxX = selection.startX + selection.floatingPixels[0].length - 1;
        maxY = selection.startY + selection.floatingPixels.length - 1;
      } else {
        minX = Math.min(selection.startX, selection.endX);
        minY = Math.min(selection.startY, selection.endY);
        maxX = Math.max(selection.startX, selection.endX);
        maxY = Math.max(selection.startY, selection.endY);
      }
      return x >= minX && x <= maxX && y >= minY && y <= maxY;
    }
    
    function liftSelection() {
      const minX = Math.min(selection.startX, selection.endX);
      const minY = Math.min(selection.startY, selection.endY);
      const maxX = Math.max(selection.startX, selection.endX);
      const maxY = Math.max(selection.startY, selection.endY);
      const width = maxX - minX + 1;
      const height = maxY - minY + 1;
      
      selection.floatingPixels = [];
      for (let dy = 0; dy < height; dy++) {
        selection.floatingPixels[dy] = [];
        for (let dx = 0; dx < width; dx++) {
          const px = minX + dx;
          const py = minY + dy;
          if (px >= 0 && px < state.w && py >= 0 && py < state.h) {
            selection.floatingPixels[dy][dx] = state.pixels[py * state.w + px];
            state.pixels[py * state.w + px] = 0;
          } else {
            selection.floatingPixels[dy][dx] = 0;
          }
        }
      }
      selection.startX = minX;
      selection.startY = minY;
      selection.endX = maxX;
      selection.endY = maxY;
    }
    
    function commitSelection() {
      if (!selection.floatingPixels) {
        clearSelection();
        return;
      }
      const minX = selection.startX;
      const minY = selection.startY;
      for (let dy = 0; dy < selection.floatingPixels.length; dy++) {
        for (let dx = 0; dx < selection.floatingPixels[dy].length; dx++) {
          const px = minX + dx;
          const py = minY + dy;
          if (px >= 0 && px < state.w && py >= 0 && py < state.h) {
            if (selection.floatingPixels[dy][dx]) {
              state.pixels[py * state.w + px] = 1;
            }
          }
        }
      }
      clearSelection();
      draw();
    }
    
    function clearSelection() {
      selection.active = false;
      selection.floatingPixels = null;
      selection.dragging = false;
      selectionOverlay.style.display = 'none';
    }
    
    function copySelection() {
      if (!selection.active) { toast('No selection to copy'); return; }
      if (selection.floatingPixels) {
        internalClipboard = selection.floatingPixels.map(row => [...row]);
      } else {
        const minX = Math.min(selection.startX, selection.endX);
        const minY = Math.min(selection.startY, selection.endY);
        const maxX = Math.max(selection.startX, selection.endX);
        const maxY = Math.max(selection.startY, selection.endY);
        const width = maxX - minX + 1;
        const height = maxY - minY + 1;
        internalClipboard = [];
        for (let dy = 0; dy < height; dy++) {
          internalClipboard[dy] = [];
          for (let dx = 0; dx < width; dx++) {
            const px = minX + dx;
            const py = minY + dy;
            internalClipboard[dy][dx] = (px >= 0 && px < state.w && py >= 0 && py < state.h) ? (state.pixels[py * state.w + px] ? 1 : 0) : 0;
          }
        }
      }
      copySelectionToSystemClipboard(internalClipboard);
      toast(`Copied ${internalClipboard[0].length}√ó${internalClipboard.length} pixels`);
    }
    
    async function copySelectionToSystemClipboard(pixels2D) {
      const width = pixels2D[0].length;
      const height = pixels2D.length;
      let text = `[Bitmap ${width}x${height}]\n`;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          text += pixels2D[y][x] ? '‚ñà' : '¬∑';
        }
        text += '\n';
      }
      try { await navigator.clipboard.writeText(text); } catch (err) {}
    }
    
    function cutSelection() {
      if (!selection.active) { toast('No selection to cut'); return; }
      pushHistory();
      if (!selection.floatingPixels) { liftSelection(); }
      internalClipboard = selection.floatingPixels.map(row => [...row]);
      selection.floatingPixels = null;
      clearSelection();
      draw();
      toast('Cut to clipboard');
    }
    
    function pasteFromInternalClipboard() {
      if (!internalClipboard) { toast('Nothing to paste'); return; }
      if (selection.floatingPixels) { commitSelection(); }
      pushHistory();
      selection.floatingPixels = internalClipboard.map(row => [...row]);
      selection.startX = 0;
      selection.startY = 0;
      selection.endX = selection.floatingPixels[0].length - 1;
      selection.endY = selection.floatingPixels.length - 1;
      selection.active = true;
      selection.dragging = false;
      state.brush = 'select';
      $$('[data-tool]').forEach(t => t.classList.remove('active'));
      $('[data-tool="select"]').classList.add('active');
      draw();
      toast('Pasted - drag to position, Escape to commit');
    }

    // --- Mouse interactions ---
    let drawing = false, startPt=null, activeMode=null, shapeBase=null;
    let selectStart = null;
    grid.addEventListener('contextmenu', e=>e.preventDefault());

    grid.addEventListener('mousedown', (e)=>{
      const {x,y} = eventToCell(e);
      const rightClick = e.button === 2;
      
      // Determine draw/erase based on click and inversion state
      let isErasing = rightClick;
      if (state.brush === 'draw' && state.drawInverted) {
        isErasing = !rightClick; // Swap: left=erase, right=draw
      }
      activeMode = isErasing ? 'erase' : state.brush;

      // Selection tool
      if (state.brush === 'select') {
        if (selection.active && isInsideSelection(x, y)) {
          selection.dragging = true;
          selection.dragOffsetX = x - selection.startX;
          selection.dragOffsetY = y - selection.startY;
          if (!selection.floatingPixels) {
            pushHistory();
            liftSelection();
          }
          return;
        } else {
          if (selection.floatingPixels) { commitSelection(); }
          selectStart = { x, y };
          selection.startX = x;
          selection.startY = y;
          selection.endX = x;
          selection.endY = y;
          selection.active = true;
          selection.floatingPixels = null;
          drawing = true;
          draw();
          return;
        }
      }

      if(['line','rect','circle'].includes(activeMode)){
        startPt = {x,y,mode: activeMode};
        shapeBase = state.pixels.slice();
        pushHistory();
        drawing = true;
        return;
      }

      // freehand or erase/fill single click
      pushHistory();
      drawing = state.dragToDraw;
      applyBrush(x,y, isErasing ? 'erase' : 'draw');
      draw();
    });

    grid.addEventListener('mousemove', (e)=>{
      const {x,y} = eventToCell(e);
      
      // Update cursor for selection
      if (state.brush === 'select' && selection.active && !drawing) {
        if (isInsideSelection(x, y)) {
          grid.classList.add('move-cursor');
        } else {
          grid.classList.remove('move-cursor');
        }
      } else if (state.brush !== 'select') {
        grid.classList.remove('move-cursor');
      }
      
      // Selection dragging
      if (state.brush === 'select' && selection.dragging) {
        selection.startX = x - selection.dragOffsetX;
        selection.startY = y - selection.dragOffsetY;
        if (selection.floatingPixels) {
          selection.endX = selection.startX + selection.floatingPixels[0].length - 1;
          selection.endY = selection.startY + selection.floatingPixels.length - 1;
        }
        draw();
        return;
      }
      
      // Selection box drawing
      if (state.brush === 'select' && drawing && selectStart) {
        selection.endX = x;
        selection.endY = y;
        draw();
        return;
      }
      
      if(!drawing) return;

      if(startPt && ['line','rect','circle'].includes(startPt.mode)){
        // rubber-band by restoring snapshot then committing the shape
        state.pixels = shapeBase.slice();
        const val = (activeMode === 'erase') ? 0 : 1;
        if(startPt.mode==='line'){
          strokeShape(startPt,x,y,false, /*commit=*/true, /*val=*/val);
        }else if(startPt.mode==='rect'){
          strokeShape(startPt,x,y,true, /*commit=*/true, /*val=*/val, state.rectFilled);
        }else{
          strokeCircle(startPt,x,y, state.circleFilled, /*commit=*/true, /*val=*/val);
        }
        draw();
        return;
      }

      // freehand
      applyBrush(x,y, activeMode === 'erase' ? 'erase' : 'draw');
      draw();
    });

    window.addEventListener('mouseup', (e)=>{
      if (state.brush === 'select') {
        selection.dragging = false;
        selectStart = null;
        drawing = false;
        return;
      }
      startPt=null; drawing=false; activeMode=null; shapeBase=null;
    });

    function eventToCell(e){
      const r = grid.getBoundingClientRect();
      const x = Math.min(state.w-1, Math.max(0, ((e.clientX - r.left)/state.zoom)|0));
      const y = Math.min(state.h-1, Math.max(0, ((e.clientY - r.top)/state.zoom)|0));
      return {x,y};
    }

    function setPx(x,y,v){ if(x<0||y<0||x>=state.w||y>=state.h) return; state.pixels[y*state.w+x]=v; }
    function getPx(x,y){ if(x<0||y<0||x>=state.w||y>=state.h) return 0; return state.pixels[y*state.w+x]|0; }

    function applyBrush(x,y,mode){
      const b = state.brush;
      if(b==='fill') return floodFill(x,y, mode==='erase'?0:1);
      setPx(x,y, mode==='erase'?0:1);
    }

    // Draw rectangle/line (with commit + val + filled support)
    function strokeShape(a,bx,by, isRect, commit=false, val=1, filled=false){
      if(isRect){
        const x0=Math.min(a.x,bx), x1=Math.max(a.x,bx), y0=Math.min(a.y,by), y1=Math.max(a.y,by);
        for(let y=y0;y<=y1;y++) {
          for(let x=x0;x<=x1;x++) {
            // For outline rect, only draw border pixels
            const isBorder = (y === y0 || y === y1 || x === x0 || x === x1);
            if (filled || isBorder) {
              if(commit) setPx(x,y,val); 
              else { g.fillStyle='white'; g.fillRect(x*state.zoom,y*state.zoom,state.zoom,state.zoom); }
            }
          }
        }
        return;
      }
      // line (Bresenham)
      let x0=a.x,y0=a.y,x1=bx,y1=by; const dx=Math.abs(x1-x0), dy=-Math.abs(y1-y0); let sx=x0<x1?1:-1, sy=y0<y1?1:-1, err=dx+dy;
      while(true){ if(commit) setPx(x0,y0,val); else { g.fillStyle='white'; g.fillRect(x0*state.zoom,y0*state.zoom,state.zoom,state.zoom);} if(x0===x1 && y0===y1) break; const e2=2*err; if(e2>=dy){err+=dy;x0+=sx;} if(e2<=dx){err+=dx;y0+=sy;} }
    }

    function floodFill(x,y,val){
      const target = getPx(x,y); if(target===val) return; const q=[[x,y]]; const W=state.w,H=state.h;
      while(q.length){ const [cx,cy]=q.pop(); if(cx<0||cy<0||cx>=W||cy>=H) continue; if(getPx(cx,cy)!==target) continue; setPx(cx,cy,val); q.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]); }
      draw();
    }

    // --- Circles ---
    // Pixel-accurate circle/disc that works for odd and even sizes.
    // We sample at pixel centers (x+0.5,y+0.5) and place the circle center
    // at the center of the inclusive square box. For even side lengths the
    // center lies between pixels, which preserves symmetry.
    function strokeCircle(a, bx, by, filled=false, commit=false, val=1){
      // Build inclusive bounding square
      let x0 = Math.min(a.x, bx), x1 = Math.max(a.x, bx);
      let y0 = Math.min(a.y, by), y1 = Math.max(a.y, by);
      let w = (x1 - x0 + 1), h = (y1 - y0 + 1);
      const side = Math.max(w, h);
      x1 = x0 + side - 1;
      y1 = y0 + side - 1;

      // Floating-point center and radius (handles even/odd uniformly)
      const cx = x0 + side / 2;   // may be .5 for odd side, integer for even side
      const cy = y0 + side / 2;
      const R  = side / 2;

      const R2 = R*R;
      const outlineLo2 = (R - 0.5)*(R - 0.5); // 1px ring thickness
      const outlineHi2 = (R + 0.5)*(R + 0.5);

      for(let y=y0; y<=y1; y++){
        for(let x=x0; x<=x1; x++){
          const dx = (x + 0.5) - cx;
          const dy = (y + 0.5) - cy;
          const d2 = dx*dx + dy*dy;
          if (filled) {
            if (d2 <= R2 + 1e-9) plotCell(x, y, commit, val);
          } else {
            if (d2 >= outlineLo2 && d2 <= outlineHi2) plotCell(x, y, commit, val);
          }
        }
      }
    }

    function plotCell(x, y, commit, val){
      if(commit){
        setPx(x,y,val?1:0);
      }else{
        g.fillStyle = val ? 'white' : '#0f1115';
        g.fillRect(x*state.zoom, y*state.zoom, state.zoom, state.zoom);
      }
    }

    // --- Import/Export ---
    function parseHexInput(str){
      const bytes=[]; str.replace(/0x[0-9a-fA-F]{1,2}|\b\d+\b/g, m=>{ bytes.push(Number(m.startsWith('0x')?m:('0x'+(+m).toString(16)))); });
      return bytes;
    }

    function importFromHex(){
      const bytes = parseHexInput(importArea.value);
      const W = +iw.value||state.w; const H = +ih.value||state.h;
      setSize(W,H); clearPixels();
      // Use main export options for bit order and padding
      const order = bitOrder.value; const pad = padRows.checked;
      let idx=0;
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const bitIndex = pad ? x%8 : ((y*W+x)%8);
          if(bitIndex===0){ var b = bytes[idx++]||0; }
          const bit = (order==='msb0') ? ((b & (0x80>>bitIndex))!==0) : ((b & (1<<bitIndex))!==0);
          setPx(x,y, bit?1:0);
        }
        if(pad){ const rem = W%8; if(rem!==0) idx += (8-rem)/8; }
      }
      saveCurrentEmote();
      draw(); toast('Imported '+bytes.length+' byte(s)');
    }

    // Clipboard image import
    async function processClipboardImage(blob) {
      const img = new Image();
      img.onload = () => {
        clipboardImage = img;
        showClipboardModal();
      };
      img.src = URL.createObjectURL(blob);
    }
    
    function showClipboardModal() {
      $('#clipboardModal').classList.add('active');
      updateClipboardPreview();
    }
    
    function hideClipboardModal() {
      $('#clipboardModal').classList.remove('active');
      clipboardImage = null;
    }
    
    function updateClipboardPreview() {
      if (!clipboardImage) return;
      
      const origCanvas = $('#clipboardOriginal');
      const binCanvas = $('#clipboardBinary');
      const origCtx = origCanvas.getContext('2d');
      const binCtx = binCanvas.getContext('2d');
      
      const scale = Math.min(96 / clipboardImage.width, 96 / clipboardImage.height);
      const scaledW = clipboardImage.width * scale;
      const scaledH = clipboardImage.height * scale;
      
      origCanvas.width = 96;
      origCanvas.height = 96;
      origCtx.fillStyle = '#1a1a2e';
      origCtx.fillRect(0, 0, 96, 96);
      origCtx.drawImage(clipboardImage, (96 - scaledW) / 2, (96 - scaledH) / 2, scaledW, scaledH);
      
      const imgW = clipboardImage.width;
      const imgH = clipboardImage.height;
      const binaryPixels = convertImageToBinary(clipboardImage, clipboardThreshold, clipboardInvert);
      
      $('#previewSize').textContent = `${imgW}√ó${imgH}px`;
      
      binCanvas.width = 96;
      binCanvas.height = 96;
      binCtx.fillStyle = '#0f1115';
      binCtx.fillRect(0, 0, 96, 96);
      
      const pxSize = Math.min(96 / imgW, 96 / imgH);
      const offsetX = (96 - imgW * pxSize) / 2;
      const offsetY = (96 - imgH * pxSize) / 2;
      
      for (let y = 0; y < imgH; y++) {
        for (let x = 0; x < imgW; x++) {
          if (binaryPixels[y][x]) {
            binCtx.fillStyle = '#e5e9f0';
            binCtx.fillRect(offsetX + x * pxSize, offsetY + y * pxSize, pxSize, pxSize);
          }
        }
      }
    }
    
    function convertImageToBinary(img, threshold, invert) {
      const tempCanvas = document.createElement('canvas');
      const imgW = img.width;
      const imgH = img.height;
      tempCanvas.width = imgW;
      tempCanvas.height = imgH;
      const ctx = tempCanvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, imgW, imgH);
      const data = imageData.data;
      
      const pixels = [];
      for (let y = 0; y < imgH; y++) {
        pixels[y] = [];
        for (let x = 0; x < imgW; x++) {
          const i = (y * imgW + x) * 4;
          const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
          let isOn = gray < threshold;
          if (invert) isOn = !isOn;
          pixels[y][x] = isOn ? 1 : 0;
        }
      }
      return pixels;
    }
    
    function applyClipboardToCanvas() {
      if (!clipboardImage) return;
      pushHistory();
      
      const binaryPixels = convertImageToBinary(clipboardImage, clipboardThreshold, clipboardInvert);
      
      selection.floatingPixels = binaryPixels;
      selection.startX = 0;
      selection.startY = 0;
      selection.endX = binaryPixels[0].length - 1;
      selection.endY = binaryPixels.length - 1;
      selection.active = true;
      selection.dragging = false;
      
      state.brush = 'select';
      $$('[data-tool]').forEach(t => t.classList.remove('active'));
      $('[data-tool="select"]').classList.add('active');
      
      hideClipboardModal();
      draw();
      toast('Image pasted - drag to position, Escape to commit');
    }
    
    // Clipboard modal events
    $('#thresholdSlider').oninput = () => {
      clipboardThreshold = parseInt($('#thresholdSlider').value);
      $('#thresholdValue').textContent = clipboardThreshold;
      updateClipboardPreview();
    };
    
    $('#invertImport').onchange = () => {
      clipboardInvert = $('#invertImport').checked;
      updateClipboardPreview();
    };
    
    $('#cancelClipboard').onclick = hideClipboardModal;
    $('#applyClipboard').onclick = applyClipboardToCanvas;
    
    $('#pasteImageBtn').onclick = async () => {
      try {
        const items = await navigator.clipboard.read();
        for (const item of items) {
          for (const type of item.types) {
            if (type.startsWith('image/')) {
              const blob = await item.getType(type);
              await processClipboardImage(blob);
              return;
            }
          }
        }
        toast('No image in clipboard');
      } catch (err) {
        toast('Clipboard access denied - use Ctrl+V');
      }
    };
    
    $('#clipboardModal').onclick = (e) => {
      if (e.target === $('#clipboardModal')) hideClipboardModal();
    };

    // Default packing order changed to LSB first
    function packBytes(order='lsb0', pad=true){
      const W=state.w,H=state.h; const bytes=[]; let cur=0, count=0;
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const bit = getPx(x,y)?1:0;
          if(order==='msb0'){ cur = (cur<<1) | bit; }
          else { cur |= (bit<<count); }
          count++;
          if(count===8){ bytes.push(order==='msb0'?cur:cur&0xFF); cur=0; count=0; }
        }
        if(pad && count!==0){ // pad remaining bits with 0
          if(order==='msb0'){ cur <<= (8-count); }
          bytes.push(cur&0xFF); cur=0; count=0; }
      }
      if(!pad && count!==0){ bytes.push(cur&0xFF); }
      return bytes;
    }

    function makeCArray(){
      const nm = (nameIn.value||'emote').replace(/\W+/g,'_');
      const sym = symbolIn.value||'';
      // Escape symbol for C string (use \u for 4-digit, \U for larger codepoints)
      const symEscaped = [...sym].map(c => {
        const cp = c.codePointAt(0);
        if (cp <= 127) return c;
        if (cp <= 0xFFFF) return '\\u' + cp.toString(16).toUpperCase().padStart(4, '0');
        return '\\U' + cp.toString(16).toUpperCase().padStart(8, '0');
      }).join('');
      const order = bitOrder.value; const pad = padRows.checked;
      const bytes = packBytes(order,pad);
      const hex = bytes.map(b=> '0x'+b.toString(16).toUpperCase().padStart(2,'0')).join(', ');
      const W=state.w,H=state.h;
      const hdr = `const unsigned char ${nm}[] ${progmem.checked?'PROGMEM ':''}= {\n    ${hex}\n};\n\nconst int ${nm}_width = ${W};\nconst int ${nm}_height = ${H};\n`;
      const emoteLine = sym? `\n// Add to your emote table:\n// { "${symEscaped}", ${nm}, ${nm}_width, ${nm}_height },\n` : '';
      return hdr + emoteLine;
    }

    // Pack bytes for a specific emote's pixels
    function packBytesForEmote(emote, order='lsb0', pad=true) {
      const W = emote.w, H = emote.h;
      const bytes = [];
      let cur = 0, count = 0;
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          const bit = emote.pixels[y * W + x] ? 1 : 0;
          if (order === 'msb0') { cur = (cur << 1) | bit; }
          else { cur |= (bit << count); }
          count++;
          if (count === 8) { bytes.push(order === 'msb0' ? cur : cur & 0xFF); cur = 0; count = 0; }
        }
        if (pad && count !== 0) {
          if (order === 'msb0') { cur <<= (8 - count); }
          bytes.push(cur & 0xFF); cur = 0; count = 0;
        }
      }
      if (!pad && count !== 0) { bytes.push(cur & 0xFF); }
      return bytes;
    }

    // Generate header file (emotes.h)
    function generateEmotesHeader() {
      saveCurrentEmote();
      const usePROGMEM = progmem.checked;
      const pm = usePROGMEM ? ' PROGMEM' : '';
      
      let code = '#pragma once\n';
      code += '#include <Arduino.h>\n\n';
      code += 'namespace graphics\n';
      code += '{\n\n';
      
      // Emote struct definition
      code += '// === Emote List ===\n';
      code += 'struct Emote {\n';
      code += '    const char *label;\n';
      code += '    const unsigned char *bitmap;\n';
      code += '    int width;\n';
      code += '    int height;\n';
      code += '};\n\n';
      
      // Extern declarations for emote table
      code += 'extern const Emote emotes[/* numEmotes */];\n';
      code += 'extern const int numEmotes;\n\n';
      
      // Bitmap declarations with #define for height/width (height first to match original)
      code += '#ifndef EXCLUDE_EMOJI\n';
      code += '// === Emote Bitmaps ===\n';
      emotes.forEach(emote => {
        const nm = emote.name.replace(/\W+/g, '_');
        code += `#define ${nm}_height ${emote.h}\n`;
        code += `#define ${nm}_width ${emote.w}\n`;
        code += `extern const unsigned char ${nm}[]${pm};\n\n`;
      });
      code += '#endif // EXCLUDE_EMOJI\n\n';
      code += '} // namespace graphics\n';
      
      return code;
    }

    // Generate implementation file (emotes.cpp)
    function generateEmotesCpp() {
      saveCurrentEmote();
      const order = bitOrder.value;
      const pad = padRows.checked;
      const usePROGMEM = progmem.checked;
      const pm = usePROGMEM ? ' PROGMEM' : '';
      
      let code = '#include "configuration.h"\n';
      code += '#if HAS_SCREEN\n';
      code += '#include "emotes.h"\n\n';
      code += 'namespace graphics\n';
      code += '{\n\n';
      
      // Generate emotes table
      code += '// === Emote Table ===\n';
      code += 'const Emote emotes[] = {\n';
      code += '#ifndef EXCLUDE_EMOJI\n';
      emotes.forEach(emote => {
        const nm = emote.name.replace(/\W+/g, '_');
        // Get symbols array (handle legacy single symbol)
        const syms = Array.isArray(emote.symbols) ? emote.symbols : (emote.symbol ? [emote.symbol] : ['']);
        // Output one table entry per symbol variation
        syms.forEach(sym => {
          // Escape symbol for C string (handles all Unicode including emojis)
          // Use \u for 4-digit codepoints (0000-FFFF), \U for larger (e.g. emoji)
          const symEscaped = [...sym].map(c => {
            const cp = c.codePointAt(0);
            if (cp <= 127) return c;
            if (cp <= 0xFFFF) return '\\u' + cp.toString(16).toUpperCase().padStart(4, '0');
            return '\\U' + cp.toString(16).toUpperCase().padStart(8, '0');
          }).join('');
          const comment = sym ? ` // ${sym} ${nm}` : '';
          code += `    {"${symEscaped}", ${nm}, ${nm}_width, ${nm}_height},${comment}\n`;
        });
      });
      code += '#endif\n';
      code += '};\n\n';
      code += `const int numEmotes = sizeof(emotes) / sizeof(emotes[0]);\n\n`;
      
      // Generate each emote's bitmap data
      code += '#ifndef EXCLUDE_EMOJI\n';
      code += '// === Emote Bitmaps ===\n';
      emotes.forEach(emote => {
        const nm = emote.name.replace(/\W+/g, '_');
        const bytes = packBytesForEmote(emote, order, pad);
        const hex = bytes.map(b => '0x' + b.toString(16).toUpperCase().padStart(2, '0')).join(', ');
        code += `const unsigned char ${nm}[]${pm} = {${hex}};\n\n`;
      });
      code += '#endif // EXCLUDE_EMOJI\n\n';
      code += '} // namespace graphics\n';
      code += '#endif // HAS_SCREEN\n';
      
      return code;
    }

    // Generate code for all emotes (combined for preview)
    function generateAllEmotesCode() {
      return generateEmotesHeader() + '\n// ========================================\n// emotes.cpp\n// ========================================\n\n' + generateEmotesCpp();
    }

    // Export emotes to files (downloads both .h and .cpp)
    function exportEmotesFile() {
      saveCurrentEmote();
      
      // Export header file
      const headerCode = generateEmotesHeader();
      const headerBlob = new Blob([headerCode], { type: 'text/plain' });
      const headerLink = document.createElement('a');
      headerLink.href = URL.createObjectURL(headerBlob);
      headerLink.download = 'emotes.h';
      headerLink.click();
      URL.revokeObjectURL(headerLink.href);
      
      // Small delay then export cpp file
      setTimeout(() => {
        const cppCode = generateEmotesCpp();
        const cppBlob = new Blob([cppCode], { type: 'text/plain' });
        const cppLink = document.createElement('a');
        cppLink.href = URL.createObjectURL(cppBlob);
        cppLink.download = 'emotes.cpp';
        cppLink.click();
        URL.revokeObjectURL(cppLink.href);
        toast('Exported emotes.h + emotes.cpp');
      }, 100);
    }

    // Import emotes from file
    function importEmotesFile() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.cpp,.h,.c,.txt';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const text = await file.text();
        parseEmotesFile(text);
      };
      input.click();
    }

    // Parse emotes.cpp format
    function parseEmotesFile(text) {
      const newEmotes = [];
      
      // Match patterns like: const unsigned char name[] PROGMEM = { 0x00, 0x1C, ... };
      const arrayRegex = /const\s+unsigned\s+char\s+(\w+)\s*\[\s*\]\s*(?:PROGMEM\s*)?=\s*\{([^}]+)\}/g;
      // Support both const int and #define formats for width/height
      const widthRegex = /(?:const\s+int\s+(\w+)_width\s*=\s*(\d+)|#define\s+(\w+)_width\s+(\d+))/g;
      const heightRegex = /(?:const\s+int\s+(\w+)_height\s*=\s*(\d+)|#define\s+(\w+)_height\s+(\d+))/g;
      // Updated regex to capture more flexible emote table entries
      const emoteTableRegex = /\{\s*"([^"]*)",\s*(\w+),\s*(\w+),\s*(\w+)\s*\}/g;
      
      // Parse arrays
      const arrays = {};
      let match;
      while ((match = arrayRegex.exec(text)) !== null) {
        const name = match[1];
        const hexStr = match[2];
        const bytes = hexStr.match(/0x[0-9A-Fa-f]{2}/g) || [];
        arrays[name] = bytes.map(h => parseInt(h, 16));
      }
      
      // Parse width/height constants (both const int and #define)
      const widths = {};
      const heights = {};
      while ((match = widthRegex.exec(text)) !== null) {
        const name = match[1] || match[3];
        const value = match[2] || match[4];
        widths[name] = parseInt(value);
      }
      while ((match = heightRegex.exec(text)) !== null) {
        const name = match[1] || match[3];
        const value = match[2] || match[4];
        heights[name] = parseInt(value);
      }
      
      // Parse emote table for symbols and dimensions
      // Format: { "symbol", arrayName, widthVar, heightVar }
      // Collect ALL symbol variations for each array name
      const emoteTableEntries = {};
      while ((match = emoteTableRegex.exec(text)) !== null) {
        // Convert escape sequences like \U0001F44D to actual emoji
        let symbol = match[1];
        symbol = symbol.replace(/\\U([0-9A-Fa-f]{8})/g, (_, hex) => String.fromCodePoint(parseInt(hex, 16)));
        symbol = symbol.replace(/\\u([0-9A-Fa-f]{4})/g, (_, hex) => String.fromCodePoint(parseInt(hex, 16)));
        const arrayName = match[2];
        const widthVarName = match[3].replace(/_width$/, '');
        const heightVarName = match[4].replace(/_height$/, '');
        if (!emoteTableEntries[arrayName]) {
          emoteTableEntries[arrayName] = {
            symbols: [],
            widthKey: widthVarName,
            heightKey: heightVarName
          };
        }
        // Add this symbol to the list if not already present
        if (symbol && !emoteTableEntries[arrayName].symbols.includes(symbol)) {
          emoteTableEntries[arrayName].symbols.push(symbol);
        }
      }
      
      // Build emotes from parsed data
      for (const name of Object.keys(arrays)) {
        const bytes = arrays[name];
        let w = 16, h = 16;
        let symbols = [];
        
        // First try direct name match for width/height
        if (widths[name]) w = widths[name];
        if (heights[name]) h = heights[name];
        
        // Then check emote table for alternative width/height keys
        const tableEntry = emoteTableEntries[name];
        if (tableEntry) {
          symbols = tableEntry.symbols;
          if (widths[tableEntry.widthKey]) w = widths[tableEntry.widthKey];
          if (heights[tableEntry.heightKey]) h = heights[tableEntry.heightKey];
        }
        
        const pixels = unpackBytes(bytes, w, h, 'lsb0', true);
        
        newEmotes.push({
          name: name,
          symbols: symbols,
          w: w,
          h: h,
          pixels: pixels
        });
      }
      
      if (newEmotes.length === 0) {
        toast('No emotes found in file');
        return;
      }
      
      emotes = newEmotes;
      currentEmote = 0;
      populateEmoteSelect();
      loadEmote(0);
      toast(`Imported ${newEmotes.length} emote(s)`);
    }

    // Unpack bytes to pixels (for import)
    function unpackBytes(bytes, w, h, order='lsb0', padded=true) {
      const pixels = new Array(w * h).fill(0);
      const bytesPerRow = padded ? Math.ceil(w / 8) : null;
      
      let byteIndex = 0;
      let bitIndex = 0;
      
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          if (byteIndex >= bytes.length) break;
          
          let bit;
          if (order === 'msb0') {
            bit = (bytes[byteIndex] >> (7 - bitIndex)) & 1;
          } else {
            bit = (bytes[byteIndex] >> bitIndex) & 1;
          }
          
          pixels[y * w + x] = bit;
          bitIndex++;
          
          if (bitIndex >= 8) {
            bitIndex = 0;
            byteIndex++;
          }
        }
        
        // If padded, skip to next byte boundary at end of row
        if (padded && bitIndex !== 0) {
          bitIndex = 0;
          byteIndex++;
        }
      }
      
      return pixels;
    }

    // Update output when emote changes
    function updateOutput() {
      out.value = makeCArray();
    }

    // --- tiny toast ---
    function toast(msg){
      const t=document.createElement('div');
      t.textContent=msg; t.style.position='fixed'; t.style.bottom='16px'; t.style.right='16px'; t.style.background='#1f2534'; t.style.border='1px solid #2e3952'; t.style.padding='10px 12px'; t.style.borderRadius='10px'; t.style.color='#d3dbeb'; t.style.boxShadow='0 10px 30px rgba(0,0,0,.25)'; t.style.zIndex=9999;
      document.body.appendChild(t); setTimeout(()=>{ t.style.transition='all .3s ease'; t.style.opacity='0'; t.style.transform='translateY(8px)'; setTimeout(()=>t.remove(),300); }, 1200);
    }

    // --- Column Resizing ---
    (function initResizeHandles() {
      const wrap = $('.wrap');
      const leftHandle = $('#leftResizeHandle');
      const rightHandle = $('#rightResizeHandle');
      
      let activeHandle = null;
      let startX = 0;
      let startLeftWidth = 280;
      let startRightWidth = 320;
      
      // Load saved widths from localStorage
      const savedLeft = localStorage.getItem('emoteEditorLeftWidth');
      const savedRight = localStorage.getItem('emoteEditorRightWidth');
      if (savedLeft) wrap.style.setProperty('--left-width', savedLeft + 'px');
      if (savedRight) wrap.style.setProperty('--right-width', savedRight + 'px');
      
      function onMouseDown(e, handle, isLeft) {
        activeHandle = handle;
        handle.classList.add('dragging');
        startX = e.clientX;
        const computedStyle = getComputedStyle(wrap);
        const cols = computedStyle.gridTemplateColumns.split(' ');
        startLeftWidth = parseFloat(cols[0]);
        startRightWidth = parseFloat(cols[cols.length - 1]);
        e.preventDefault();
        
        document.addEventListener('mousemove', isLeft ? onMouseMoveLeft : onMouseMoveRight);
        document.addEventListener('mouseup', onMouseUp);
      }
      
      function onMouseMoveLeft(e) {
        const delta = e.clientX - startX;
        const newWidth = Math.max(200, Math.min(500, startLeftWidth + delta));
        wrap.style.setProperty('--left-width', newWidth + 'px');
      }
      
      function onMouseMoveRight(e) {
        const delta = startX - e.clientX;
        const newWidth = Math.max(250, Math.min(500, startRightWidth + delta));
        wrap.style.setProperty('--right-width', newWidth + 'px');
      }
      
      function onMouseUp() {
        if (activeHandle) {
          activeHandle.classList.remove('dragging');
          // Save widths to localStorage
          const computedStyle = getComputedStyle(wrap);
          const cols = computedStyle.gridTemplateColumns.split(' ');
          localStorage.setItem('emoteEditorLeftWidth', parseFloat(cols[0]));
          localStorage.setItem('emoteEditorRightWidth', parseFloat(cols[cols.length - 1]));
        }
        activeHandle = null;
        document.removeEventListener('mousemove', onMouseMoveLeft);
        document.removeEventListener('mousemove', onMouseMoveRight);
        document.removeEventListener('mouseup', onMouseUp);
      }
      
      leftHandle.addEventListener('mousedown', (e) => onMouseDown(e, leftHandle, true));
      rightHandle.addEventListener('mousedown', (e) => onMouseDown(e, rightHandle, false));
    })();
  </script>
</body>
</html>
